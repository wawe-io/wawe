<!DOCTYPE html>
<html>
<head>
<title>Weather Dashboard with Multiple Metrics</title>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css">
<script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://cdn.jsdelivr.net/npm/luxon@3.0.1"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-luxon@1.2.0"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@1.0.2"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
<link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
<style>
:root {
    --primary: #3f37c9;
    --secondary: #3f37c9;
    --success: #4cc9f0;
    --danger: #f72585;
    --warning: #f8961e;
    --light: #f8f9fa;
    --dark: #212529;
    --text: #2b2d42;
    --muted: #6c757d;
}
body {
    font-family: 'Poppins', sans-serif;
    margin: 0;
    padding: 0;
    overflow: hidden;
    color: var(--text);
}
#container {
    display: grid;
    grid-template-columns: 1fr 1fr;
    grid-template-rows: auto 1fr;
    height: 100vh;
    gap: 10px;
    padding: 10px;
    background-color: #f5f7fa;
}
#left-panel {
    grid-column: 1;
    grid-row: 1 / span 2;
    display: flex;
    flex-direction: column;
    gap: 10px;
    background-color:rgba(238, 233, 233, 0.818);
    border-radius: 8px;
    padding: 15px;
    box-shadow: 0 1px 3px rgba(0,0,0,.1);
}
.left-panel-header {
    color: black;
    font-size: 1.5rem;
    font-weight: 600;
    margin-bottom: 10px;
    text-align: center;
    text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
}
#map-container {
    position: relative;
    border-radius: 8px;
    overflow: hidden;
    box-shadow: 0 1px 3px rgba(0,0,0,.1);
    flex: 1;
    min-height: 300px;
    background-color: white;
}
#map {
    width: 100%;
    height: 100%;
}
#visualizer-container {
    background: #fff;
    border-radius: 8px;
    box-shadow: 0 1px 3px rgba(0,0,0,.1);
    overflow: hidden;
    flex: 1;
    min-height: 300px;
    display: flex;
    flex-direction: column;
}
#right-panel {
    grid-column: 2;
    grid-row: 1 / span 2;
    display: flex;
    flex-direction: column;
    background: #fff;
    border-radius: 8px;
    box-shadow: 0 1px 3px rgba(0,0,0,.1);
    overflow: hidden;
    height: 100%; 
}
.map-controls {
    position: absolute;
    top: 20px;
    right: 20px;
    z-index: 1000;
    display: flex;
    flex-direction: column;
    gap: 10px;
    background: rgba(255,255,255,0.9);
    padding: 15px;
    border-radius: 8px;
    box-shadow: 0 1px 5px rgba(0,0,0,.2);
    width: 220px;
    backdrop-filter: blur(5px);
}
.map-controls-group {
    margin-bottom: 10px;
}
.map-controls-label {
    font-size: 12px;
    font-weight: 500;
    margin-bottom: 5px;
    display: block;
    color: black;
}
.map-layer-select, .province-select {
    width: 100%;
    padding: 8px 12px;
    border: 1px solid #ddd;
    border-radius: 4px;
    font-size: 14px;
    background-color: #fff;
    cursor: pointer;
    transition: all 0.2s;
}
.map-layer-select:focus, .province-select:focus {
    outline: 0;
    border-color: var(--primary);
    box-shadow: 0 0 0 2px rgba(67, 97, 238, 0.2);
}
.metric-point {
    width: 38px;
    height: 38px;
    border-radius: 50%;
    border: 2px solid white;
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    display: flex;
    justify-content: center;
    align-items: center;
    color: white;
    font-weight: bold;
    font-size: 16px;
    transform: translate(-50%, -50%);
    text-shadow: 1px 1px 2px rgba(0,0,0,0.7);
}
.metric-point:hover {
    transform: translate(-50%, -50%) scale(1.4);
    z-index: 1000;
}
.metric-point.temp-negative { background-color: #3498db; }
.metric-point.temp-zero { background-color: #b6bcb9; }
.metric-point.temp-positive { background-color: #e74c3c; }
.metric-point.wind-calm { background-color: #1a5276; }
.metric-point.wind-light { background-color: #2874a6; }
.metric-point.wind-moderate { background-color: #3498db; }
.metric-point.wind-strong { background-color: #5dade2; }
.metric-point.wind-gale { background-color: #85c1e9; }
.metric-point.wind-storm { background-color: #aed6f1; }
.metric-point.humid-dry { background-color: #1d8348; }
.metric-point.humid-comfortable { background-color: #28b463; }
.metric-point.humid-humid { background-color: #58d68d; }
.metric-point.humid-very-humid { background-color: #abebc6; }
.metric-point.pressure-low { background-color: #6c3483; }
.metric-point.pressure-normal { background-color: #8e44ad; }
.metric-point.pressure-high { background-color: #bb8fce; }
.metric-point.visibility-poor { background-color: #b9770e; }
.metric-point.visibility-moderate { background-color: #d68910; }
.metric-point.visibility-good { background-color: #f39c12; }
.metric-point.visibility-excellent { background-color: #f8c471; }
.metric-legend {
    position: absolute;
    bottom: 20px;
    left: 20px;
    right: 20px;
    z-index: 1000;
    background: rgba(255,255,255,0.9);
    padding: 10px 15px;
    border-radius: 8px;
    box-shadow: 0 1px 5px rgba(0,0,0,.2);
    backdrop-filter: blur(5px);
    display: flex;
    flex-direction: column;
}
.metric-legend-title {
    font-size: 12px;
    font-weight: 600;
    margin-bottom: 8px;
    color: var(--text);
    text-align: center;
}
.metric-legend-scale {
    display: flex;
    height: 20px;
    width: 100%;
    border-radius: 4px;
    overflow: hidden;
}
.metric-legend-labels {
    display: flex;
    justify-content: space-between;
    margin-top: 5px;
}
.metric-legend-label {
    font-size: 10px;
    color: var(--text);
}
.metric-switcher {
    position: absolute;
    bottom: 120px;
    right: 20px;
    z-index: 2000;
    background: rgba(255,255,255,0.9);
    padding: 5px;
    border-radius: 8px;
    box-shadow: 0 1px 5px rgba(0,0,0,.2);
    backdrop-filter: blur(5px);
    display: flex;
    align-items: center;
}
.metric-btn {
    background: none;
    border: none;
    padding: 5px 10px;
    cursor: pointer;
    font-size: 12px;
    color: var(--muted);
    transition: all 0.2s;
}
.metric-btn.active {
    color: black;
    font-weight: 500;
}
.metric-btn i {
    font-size: 14px;
}
.visualizer-city-switcher {
    padding: 15px;
    display: flex;
    align-items: center;
    gap: 10px;
    background: rgba(255,255,255,0.8);
    border-bottom: 1px solid #eee;
}
.visualizer-city-switcher select {
    padding: 8px 12px;
    border-radius: 4px;
    border: 1px solid #ddd;
    flex-grow: 1;
    font-family: inherit;
}
.visualizer-city-switcher button {
    padding: 8px 15px;
    background-color: var(--primary);
    color: #fff;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-family: inherit;
    transition: all 0.2s;
}
.visualizer-city-switcher button:hover {
    background-color: var(--secondary);
}
.visualizer-city-switcher button:disabled {
    background-color: #ccc;
    cursor: not-allowed;
}
.visualizer-loading {
    text-align: center;
    padding: 40px 20px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    height: 100%;
}
.loading-spinner {
    border: 3px solid rgba(0,0,0,.1);
    border-radius: 50%;
    border-top: 3px solid var(--primary);
    width: 30px;
    height: 30px;
    animation: spin 1s linear infinite;
    margin: 0 auto 15px;
}
@keyframes spin {
    to { transform: rotate(360deg); }
}
.visualizer-error {
    color: var(--danger);
    padding: 15px;
    margin: 15px;
    background-color: #fee;
    border-radius: 5px;
    display: none;
}
.visualizer-visuals {
    padding: 15px;
    flex-grow: 1;
    
}
.visuals-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
    gap: 20px;
}

.visual-card {
    border: 1px solid #ddd;
    border-radius: 10px;
    overflow: hidden;
    box-shadow: 0 4px 8px rgba(0,0,0,.1);
    transition: all 0.3s ease;
    aspect-ratio: 1/0.8;
    display: flex;
    flex-direction: column;
    background: #fff;
    cursor: pointer;
}

.visual-card:hover {
    transform: translateY(-5px);
    box-shadow: 0 8px 20px rgba(0,0,0,.15);
}

.visual-card-header {
    padding: 20px;
    flex-grow: 1;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    text-align: center;
}

.visual-card-header h3 {
    margin: 0 0 15px 0;
    font-size: 18px;
    color: #000;
    font-weight: 600;
}

.value-container {
    display: flex;
    align-items: baseline;
    gap: 8px;
    margin-bottom: 15px;
}

.current-value {
    font-size: 24px;
    font-weight: 700;
    color: #000;
}

.unit {
    font-size: 14px;
    color: #000;
}

.imperial-container {
    display: flex;
    align-items: baseline;
    gap: 4px;
    margin-left: 8px;
}

.current-value-imperial {
    font-size: 18px;
    color: var(--muted);
}

.unit-imperial {
    font-size: 12px;
    color: var(--muted);
}

.sparkline-container {
    width: 100%; 
    height: 60px;
    margin-top: auto;
}

.no-visuals {
    text-align: center;
    padding: 30px;
    color: #666;
    grid-column: 1/-1;
}
.controls-container {
    padding: 20px;
    overflow-y: auto;
    flex: 1;
    overflow-y: auto;
    flex: 1;
    display: flex;
    flex-direction: column;
    gap: 20px;
}
.current-date {
    font-size: 1.5em;
    font-weight: 700;
    color: var(--text);
    margin-bottom: 20px;
    padding-top: 15px;
    text-align: center;
    width: 100%;
}
.glass-card {
    background: rgba(255,255,255,0.9);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border-radius: 16px;
    box-shadow: 0 8px 32px rgba(31,38,135,.1);
    border: 1px solid rgba(255,255,255,.18);
    overflow: hidden;
    margin-bottom: 20px;
    max-height: 100%;
    display: flex;
    flex-direction: column;
}
.event-planner-header {
    text-align: center;
    padding: 1.5rem 1rem;
    background: linear-gradient(135deg, var(--primary) 0, var(--secondary) 100%);
    color: #fff;
    border-radius: 16px 16px 0 0;
    position: relative;
    overflow: hidden;
}
.event-planner-title {
    font-weight: 700;
    font-size: 1.5rem;
    margin-bottom: .5rem;
    text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
}
.event-planner-subtitle {
    font-weight: 300;
    opacity: .9;
    font-size: .9rem;
    text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
}
.event-planner-content {
    padding: 1.5rem;
}
.event-planner-loading {
    text-align: center;
    padding: 1rem;
    color: var(--muted);
    font-style: italic;
    animation: pulse 2s infinite;
}
@keyframes pulse {
    0% { opacity: .6 }
    50% { opacity: 1 }
    100% { opacity: .6 }
}
.week-days {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(90px, 1fr));
    gap: .7rem;
    margin-bottom: 1.5rem;
}
.day-box {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 1rem .5rem;
    border-radius: 12px;
    cursor: pointer;
    transition: all .3s cubic-bezier(.25,.8,.25,1);
    position: relative;
    overflow: hidden;
    z-index: 1;
    color: #fff;
    text-shadow: 1px 1px 2px rgba(0,0,0,0.7);
}
.day-box::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0,0,0,.1);
    z-index: -1;
}
.day-box:hover {
    transform: translateY(-5px) scale(1.03);
    box-shadow: 0 10px 20px rgba(0,0,0,.15);
}
.day-name {
    font-weight: 600;
    font-size: .95rem;
    margin-bottom: .5rem;
}
.weather-icon {
    font-size: 1.5rem;
    margin-bottom: .8rem;
    transition: all .3s;
}
.temp-display {
    font-size: .9rem;
    background: rgba(255,255,255,.25);
    padding: .3rem .8rem;
    border-radius: 20px;
    backdrop-filter: blur(5px);
}
.event-form {
    display: flex;
    flex-direction: column;
    gap: 1rem;
}
.form-group {
    display: flex;
    flex-direction: column;
    margin-bottom: .5rem;
}
.event-planner-label {
    font-weight: 500;
    margin-bottom: .5rem;
    color: var(--text);
    font-size: .95rem;
}
.event-planner-input, .event-planner-textarea {
    padding: .8rem 1rem;
    border: 1px solid rgba(0,0,0,.1);
    border-radius: 8px;
    font-size: 1rem;
    transition: all .3s;
    background: rgba(255,255,255,.7);
    width: 100%;
    font-family: inherit;
}
.event-planner-input:focus, .event-planner-textarea:focus {
    outline: 0;
    border-color: var(--primary);
    box-shadow: 0 0 0 3px rgba(67,97,238,.2);
    background: #fff;
}
.event-planner-textarea {
    min-height: 100px;
    resize: vertical;
}
.submit-btn {
    background: linear-gradient(135deg, var(--primary) 0, var(--secondary) 100%);
    color: #fff;
    border: none;
    padding: .8rem 1.5rem;
    border-radius: 8px;
    font-size: 1rem;
    font-weight: 500;
    cursor: pointer;
    transition: all .3s;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    align-self: flex-start;
    box-shadow: 0 4px 6px rgba(0,0,0,.1);
    position: relative;
    overflow: hidden;
    margin-top: .5rem;
    font-family: inherit;
    text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
}
.submit-btn::before {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255,255,255,.2), transparent);
    transition: .5s;
}
.submit-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 12px rgba(0,0,0,.15);
}
.submit-btn:hover::before {
    left: 100%;
}
.submit-btn i {
    margin-right: .5rem;
}
.selected {
    transform: scale(1.05);
    box-shadow: 0 0 0 3px #fff, 0 8px 25px rgba(0,0,0,.2);
    z-index: 2;
}
.not-selected {
    filter: grayscale(70%) brightness(.9);
    opacity: .7;
    transform: scale(.95);
}
.event-planner-footer {
    text-align: center;
    margin-top: 1rem;
    color: var(--muted);
    font-size: .8rem;
}
.modal {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0,0,0,.85);
    z-index: 2000;
    justify-content: center;
    align-items: center;
}
.modal-content {
    background: #fff;
    padding: 25px;
    border-radius: 10px;
    width: 90%;
    max-width: 1400px;
    max-height: 90vh;
    overflow-y: auto;
}
.modal-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding-bottom: 20px;
    margin-bottom: 20px;
    border-bottom: 2px solid #eee;
}
.modal-title {
    font-size: 28px;
    font-weight: 700;
    color: var(--text);
}
.close-modal {
    font-size: 32px;
    cursor: pointer;
    color: var(--danger);
    transition: color 0.3s;
}
.close-modal:hover {
    color: var(--danger);
    transform: scale(1.1);
}
.modal-chart-container {
    position: relative;
    width: 100%;
    height: 700px;
    margin-bottom: 20px;
}
.modal-current-value {
    font-size: 22px;
    font-weight: 600;
    color: rgba(255, 87, 34, 0.9);
    margin-bottom: 20px;
    text-align: center;
}
.chart-container {
    width: 100%;
    height: 100%;
}
.weather-popup {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: white;
    padding: 20px;
    border-radius: 10px;
    box-shadow: 0 5px 15px rgba(0,0,0,0.3);
    z-index: 3000;
    max-width: 400px;
    width: 90%;
    animation: fadeIn 0.3s ease-out;
}
.weather-popup-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 15px;
    padding-bottom: 10px;
    border-bottom: 1px solid #eee;
}
.weather-popup-title {
    font-size: 1.3rem;
    font-weight: 600;
    color: var(--primary);
    margin: 0;
    text-shadow: none;
}
.weather-popup-close {
    font-size: 1.5rem;
    cursor: pointer;
    color: var(--muted);
    transition: color 0.2s;
}
.weather-popup-close:hover {
    color: var(--danger);
}
.weather-popup-content {
    margin-bottom: 15px;
}
.weather-popup-row {
    display: flex;
    margin-bottom: 10px;
    align-items: center;
}
.weather-popup-icon {
    font-size: 1.8rem;
    width: 50px;
    text-align: center;
    margin-right: 15px;
    color: var(--primary);
}
.weather-popup-details {
    flex: 1;
}
.weather-popup-label {
    font-weight: 500;
    color: var(--text);
    margin-bottom: 3px;
}
.weather-popup-value {
    font-size: 1.1rem;
    color: #333;
}
.weather-popup-footer {
    text-align: center;
    font-size: 0.9rem;
    color: var(--muted);
    margin-top: 15px;
    padding-top: 10px;
    border-top: 1px solid #eee;
}
.metrics-summary-popup {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: white;
    padding: 20px;
    border-radius: 10px;
    box-shadow: 0 5px 15px rgba(0,0,0,0.3);
    z-index: 3000;
    max-width: 400px;
    width: 90%;
    animation: fadeIn 0.3s ease-out;
}
.metrics-summary-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 15px;
    padding-bottom: 10px;
    border-bottom: 1px solid #eee;
}
.metrics-summary-title {
    font-size: 1.3rem;
    font-weight: 600;
    color: var(--primary);
    margin: 0;
}
.metrics-summary-close {
    font-size: 1.5rem;
    cursor: pointer;
    color: var(--muted);
    transition: color 0.2s;
}
.metrics-summary-close:hover {
    color: var(--danger);
}
.metrics-summary-content {
    margin-bottom: 15px;
}
.metrics-summary-row {
    display: flex;
    margin-bottom: 10px;
    align-items: center;
}
.metrics-summary-icon {
    font-size: 1.5rem;
    width: 40px;
    text-align: center;
    margin-right: 15px;
    color: var(--primary);
}
.metrics-summary-details {
    flex: 1;
}
.metrics-summary-label {
    font-weight: 500;
    color: var(--text);
    margin-bottom: 3px;
}
.metrics-summary-value {
    font-size: 1rem;
    color: #333;
}
.metrics-summary-footer {
    text-align: center;
    font-size: 0.9rem;
    color: var(--muted);
    margin-top: 15px;
    padding-top: 10px;
    border-top: 1px solid #eee;
}
.compare-modal {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0,0,0,.7);
    z-index: 2000;
    justify-content: center;
    align-items: center;
}
.compare-modal-content {
    background: #fff;
    padding: 25px;
    border-radius: 10px;
    width: 90%;
    max-width: 1200px;
    max-height: 90vh;
    overflow-y: auto;
}
.compare-modal-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 20px;
}
.compare-modal-title {
    font-size: 24px;
    font-weight: 700;
    color: var(--text);
}
.close-compare-modal {
    font-size: 28px;
    cursor: pointer;
    color: var(--muted);
    transition: color 0.2s;
}
.close-compare-modal:hover {
    color: var(--danger);
}
.compare-modal-body {
    display: flex;
    flex-direction: column;
    gap: 20px;
}
.compare-controls {
    display: flex;
    gap: 15px;
    align-items: center;
    margin-bottom: 15px;
}
.compare-metric-select {
    padding: 8px 12px;
    border-radius: 4px;
    border: 1px solid #ddd;
    font-family: inherit;
}
.compare-chart-container {
    position: relative;
    width: 100%;
    height: 500px;
}
.compare-chart {
    width: 100%;
    height: 100%;
}
.compare-city-list {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    margin-top: 15px;
}
.compare-city-checkbox {
    display: none;
}
.compare-city-label {
    display: inline-block;
    padding: 5px 10px;
    background: #f0f2f5;
    border-radius: 20px;
    cursor: pointer;
    transition: all 0.2s;
}
.compare-city-checkbox:checked + .compare-city-label {
    background: var(--primary);
    color: white;
}
.compare-city-label:hover {
    background: #e0e2e5;
}
.compare-city-checkbox:checked + .compare-city-label:hover {
    background: var(--secondary);
}
@keyframes fadeIn {
    from { opacity: 0; transform: translate(-50%, -55%); }
    to { opacity: 1; transform: translate(-50%, -50%); }
}
.loading-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(255,255,255,0.9);
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    z-index: 9999;
}
.loading-overlay-spinner {
    border: 5px solid rgba(0,0,0,.1);
    border-radius: 50%;
    border-top: 5px solid var(--primary);
    width: 50px;
    height: 50px;
    animation: spin 1s linear infinite;
    margin-bottom: 20px;
}
.loading-overlay-text {
    font-size: 1.2rem;
    color: var(--text);
    margin-top: 15px;
}
.compare-btn-container {
    position: absolute;
    bottom: 170px;
    right: 20px;
    z-index: 2000;
    background: rgba(255,255,255,0.9);
    padding: 5px;
    border-radius: 8px;
    box-shadow: 0 1px 5px rgba(0,0,0,.2);
    backdrop-filter: blur(5px);
}
.compare-btn {
    background: none;
    border: none;
    padding: 5px 10px;
    cursor: pointer;
    font-size: 12px;
    color: var(--muted);
    transition: all 0.2s;
    display: flex;
    align-items: center;
    gap: 5px;
}
.compare-btn:hover {
    color: var(--primary);
}
.compare-btn i {
    font-size: 14px;
}
@media (max-width: 1200px) {
    #container {
        grid-template-columns: 1fr;
        grid-template-rows: auto auto auto;
    }
    #left-panel {
        grid-column: 1;
        grid-row: 1;
    }
    #right-panel {
        grid-column: 1;
        grid-row: 2;
    }
    #visualizer-container {
        grid-column: 1;
        grid-row: 3;
    }
}
.activity-heatmap {
    margin-top: 20px;
    border-radius: 8px;
    overflow: hidden;
    box-shadow: 0 2px 4px rgba(0,0,0,.1);
    position: relative;
}
.heatmap-header {
    background: linear-gradient(135deg, #4361ee 0, #3f37c9 100%);
    color: white;
    padding: 10px 15px;
    font-weight: 600;
    text-align: center;
}
.heatmap-container {
    background: white;
    padding: 15px;
}
.heatmap-grid {
    display: grid;
    grid-template-columns: repeat(7, 1fr);
    gap: 5px;
}
.heatmap-cell {
    width: 95%;
    height: 100%;
    border-radius: 10px;
}
.heatmap-legend {
    bottom: 10px;
    right: 10px;
    top: 10px;
    background: rgba(255, 255, 255, 0.9);
    padding: 8px;
    border-radius: 4px;
    box-shadow: 0 1px 3px rgba(0,0,0,0.2);
    display: flex;
    flex-direction: column;
    align-items: center;
    z-index: 10;
}
.heatmap-legend-title {
    font-size: 15px;
    margin-bottom: 5px;
    color: #2b2d42;
}
.heatmap-legend-scale {
    display: flex;
    height: 15px;
    width: 100%;
    border-radius: 3px;
    overflow: hidden;
    margin-bottom: 3px;
    background: linear-gradient(to right, #ff0000, #ffff00, #00ff00);
}
.heatmap-legend-labels {
    display: flex;
    justify-content: space-between;
    width: 100%;
}
.heatmap-legend-label {
    font-size: 15px;
    color: #2b2d42;
}
.heatmap-chart-container {
    display: flex;
    flex-direction: column;
    margin-top: -7px;
}
.heatmap-chart {
    display: flex;
    height: 300px;
}
.heatmap-chart-y-axis {
    display: flex;
    flex-direction: column;
    justify-content: space-between;
    width: 150px;
    padding-right: 10px;
    text-align: left;
}
.heatmap-chart-y-label {
    font-size: 14px;
    font-weight: 500;
    display: flex;
    align-items: center;
    padding: 5px;
    height: 60px;
    box-sizing: border-box;
}
.heatmap-chart-y-label i {
    margin-right: 10px;
    width: 20px;
    text-align: center;
}
.heatmap-chart-content {
    flex: 1;
    display: grid;
    grid-template-columns: repeat(7, 1fr);
    gap: 5px;
}
.heatmap-chart-x-axis {
    display: grid;
    grid-template-columns: repeat(7, 1fr);
    margin-left: 150px;
    padding-bottom: 5px;
    order: -1;
}
.heatmap-chart-x-label {
    font-size: 14px;
    text-align: center;
    padding: 5px 0;
}
.info-button {
    position: fixed;
    top: 20px;
    right: 20px;
    width: 40px;
    height: 40px;
    background-color: var(--secondary);
    color: white;
    border-radius: 50%;
    display: flex;
    justify-content: center;
    align-items: center;
    cursor: pointer;
    z-index: 1000;
    box-shadow: 0 2px 10px rgba(0,0,0,0.2);
    transition: all 0.3s ease;
}
.info-button:hover {
    background-color: var(--secondary);
    transform: scale(1.1);
}
.info-panel {
    position: fixed;
    top: 70px;
    right: 20px;
    width: 300px;
    background: white;
    border-radius: 8px;
    box-shadow: 0 5px 15px rgba(0,0,0,0.2);
    padding: 15px;
    z-index: 1000;
    display: none;
    animation: fadeIn 0.3s ease-out;
}
.info-panel h3 {
    margin-top: 0;
    color: var(--primary);
    border-bottom: 1px solid #eee;
    padding-bottom: 10px;
}
.info-panel ul {
    padding-left: 20px;
}
.info-panel li {
    margin-bottom: 8px;
}
.info-panel a {
    color: var(--primary);
    text-decoration: none;
}
.info-panel a:hover {
    text-decoration: underline;
}
.info-panel .close-btn {
    position: absolute;
    top: 10px;
    right: 10px;
    cursor: pointer;
    color: var(--muted);
}
@keyframes fadeIn {
    from { opacity: 0; transform: translateY(-10px); }
    to { opacity: 1; transform: translateY(0); }
}
</style>
</head>
<body>
<div class="info-button" id="infoButton">
    <i class="fas fa-info"></i>
</div>
<div class="info-panel" id="infoPanel">
    <span class="close-btn" id="closeInfoPanel">&times;</span>
    <h3>Data Sources & Information</h3>
    <p>This dashboard uses weather data from:</p>
    <ul>
        <li><a href="https://geo.weather.gc.ca/" target="_blank">GeoMet Weather API</a></li>
        <li><a href="https://weather.gc.ca/" target="_blank">Environment Canada</a></li>
    </ul>
    <h4>Outdoor Activities & Weather</h4>
    <ul>
        <li><a href="https://www.weather.gov/safety" target="_blank">Weather Safety Guide (NOAA)</a></li>
        <li><a href="https://www.weather.gov/outdoorrecreation" target="_blank">Outdoor Recreation Weather</a></li>
        <li><a href="https://www.mountain-forecast.com/weather_maps" target="_blank">Mountain Weather Patterns</a></li>
    </ul>
</div>
<div class="loading-overlay" id="loadingOverlay">
    <div class="loading-overlay-spinner"></div>
    <div class="loading-overlay-text">Loading weather data for all cities...</div>
</div>
<div id="container">
    <div id="left-panel">
        <div class="left-panel-header">24-Hour City Outlook</div>
        <div id="map-container">
            <div id="map"></div>
            <div class="map-controls">
                <div class="map-controls-group">
                    <label class="map-controls-label">Map Style</label>
                    <select class="map-layer-select" id="mapLayerSelect">
                        <option value="osm" selected>Classic</option>
                        <option value="osm-classic">Detailed</option>
                        <option value="osm-humanitarian">Humanitarian - Track and Fields</option>
                        <option value="carto-positron">Light mode</option>
                        <option value="carto-dark">Dark mode</option>
                        <option value="esri-imagery">Satellite</option>
                        <option value="esri-topo">Topography</option>
                    </select>
                </div>
            </div>
            <div class="metric-switcher">
                <button class="metric-btn" id="prevMetricBtn"><i class="fas fa-chevron-left"></i></button>
                <button class="metric-btn active" id="currentMetricBtn">Temperature</button>
                <button class="metric-btn" id="nextMetricBtn"><i class="fas fa-chevron-right"></i></button>
            </div>
            <div class="compare-btn-container">
                <button class="compare-btn" id="compareBtn">
                    <i class="fas fa-chart-bar"></i> Compare Cities
                </button>
            </div>
            <button class="expand-map-btn" id="expandMapBtn">
                <i class="fas fa-expand"></i>
            </button>
            <div class="metric-legend" id="metricLegend">
                <div class="metric-legend-title" id="metricLegendTitle">Temperature (°C)</div>
                <div class="metric-legend-scale" id="metricLegendScale" style="background: linear-gradient(to right, #3498db, #b6bcb9, #e74c3c);"></div>
                <div class="metric-legend-labels" id="metricLegendLabels">
                    <div class="metric-legend-label">-20°</div>
                    <div class="metric-legend-label">0°</div>
                    <div class="metric-legend-label">20°</div>
                </div>
            </div>
        </div>
        <div id="visualizer-container">
            <div class="visualizer-city-switcher">
                <select id="visualizerCitySelect">
                    <option value="ybr">Brandon (YBR)</option>
                    <option value="yqg">Bridgewater (YQG)</option>
                    <option value="yyc">Calgary (YYC)</option>
                    <option value="yyg">Charlottetown (YYG)</option>
                    <option value="yeg">Edmonton (YEG)</option>
                    <option value="yfc">Fredericton (YFC)</option>
                    <option value="yhz">Halifax (YHZ)</option>
                    <option value="ywk">Labrador City (Wabush) (YWK)</option>
                    <option value="yxu">London (YXU)</option>
                    <option value="yul">Montreal (YUL)</option>
                    <option value="yow">Ottawa (YOW)</option>
                    <option value="yqb">Quebec City (YQB)</option>
                    <option value="yqr" selected>Regina (YQR)</option>
                    <option value="ysj">Saint John (YSJ)</option>
                    <option value="yxe">Saskatoon (YXE)</option>
                    <option value="wsd">Summerside (YRY)</option>
                    <option value="yyz">Toronto (YYZ)</option>
                    <option value="yvr">Vancouver (YVR)</option>
                    <option value="yyj">Victoria (YYJ)</option>
                    <option value="yxy">Whitehorse (YXY)</option>
                    <option value="ywg">Winnipeg (YWG)</option>
                    <option value="yzf">Yellowknife (YZF)</option>
                </select>
                <button id="visualizerFetchBtn">Update</button>
            </div>
            <div id="visualizerLoading" class="visualizer-loading">
                <div class="loading-spinner"></div>
                <p>Loading weather data...</p>
            </div>
            <div id="visualizerError" class="visualizer-error"></div>
            <div id="visualizerVisuals" class="visualizer-visuals">
                <div id="visualizerGrid" class="visuals-grid"></div>
            </div>
        </div>
    </div>
    <div id="right-panel">
        <div id="controls-container">
            <div class="current-date" id="currentDate"></div>
            <div class="glass-card">
                <div class="event-planner-header">
                    <div class="event-planner-title">Weather Event Planner</div>
                    <div class="event-planner-subtitle">Plan your outdoor activities based on weather forecasts</div>
                </div>
                <div class="event-planner-content">
                    <div id="eventPlannerLoading" class="event-planner-loading">
                        <i class="fas fa-cloud-sun fa-spin" style="font-size:1.5rem;margin-bottom:.5rem"></i>
                        <p>Fetching latest weather data...</p>
                    </div>
                    <div class="week-days" id="weekDays" style="display:none"></div>
                    <div class="event-form">
                        <div class="form-group">
                            <label for="eventName" class="event-planner-label"><i class="fas fa-calendar-alt"></i> Event Name</label>
                            <input type="text" id="eventName" class="event-planner-input" placeholder="e.g., Garden Party, Marathon, Outdoor Wedding">
                        </div>
                        <div class="form-group">
                            <label for="eventDetails" class="event-planner-label"><i class="fas fa-info-circle"></i> Event Details</label>
                            <textarea id="eventDetails" class="event-planner-textarea" placeholder="Describe your event including time, expected attendance, special requirements, etc."></textarea>
                        </div>
                        <button class="submit-btn" id="sendEmailBtn"><i class="fas fa-paper-plane"></i> Generate Event Plan</button>
                    </div>
                </div>
                <div class="event-planner-footer">
                    <p>Powered by Environment Canada Weather Data</p>
                </div>
            </div>
        </div>
        <div class="glass-card" style="margin-top: 20px;">
            <div class="activity-heatmap" id="activityHeatmap">
                <div class="heatmap-header">
                    <i class="fas fa-fire"></i> Outdoor Activity Recommendations
                </div>
                <div class="heatmap-container">
                    <div class="heatmap-chart-container">
                        <div class="heatmap-chart">
                            <div class="heatmap-chart-y-axis" id="heatmapYAxis"></div>
                            <div class="heatmap-chart-content" id="heatmapContent"></div>
                        </div>
                        <div class="heatmap-chart-x-axis" id="heatmapXAxis"></div>
                    </div>
                    <div class="heatmap-legend">
                        <div class="heatmap-legend-title">Activity Suitability</div>
                        <div class="heatmap-legend-scale"></div>
                        <div class="heatmap-legend-labels">
                            <div class="heatmap-legend-label">Poor</div>
                            <div class="heatmap-legend-label">Fair</div>
                            <div class="heatmap-legend-label">Good</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<div class="modal" id="visualizerModal">
    <div class="modal-content">
        <div class="modal-header">
            <h2 class="modal-title" id="visualizerModalTitle">Metric Name</h2>
            <span class="close-modal">&times;</span>
        </div>
        <div class="modal-current-value" id="visualizerModalCurrentValue">--</div>
        <div class="modal-chart-container">
            <canvas id="visualizerModalChart"></canvas>
        </div>
    </div>
</div>
<div class="weather-popup" id="weatherPopup" style="display: none;">
    <div class="weather-popup-header">
        <h3 class="weather-popup-title" id="weatherPopupTitle">Weather Forecast</h3>
        <span class="weather-popup-close" id="weatherPopupClose">&times;</span>
    </div>
    <div class="weather-popup-content" id="weatherPopupContent">
    </div>
    <div class="weather-popup-footer">
        Powered by Environment Canada Weather Data
    </div>
</div>
<div class="metrics-summary-popup" id="metricsSummaryPopup" style="display: none;">
    <div class="metrics-summary-header">
        <h3 class="metrics-summary-title" id="metricsSummaryTitle">Current Weather Metrics</h3>
        <span class="metrics-summary-close" id="metricsSummaryClose">&times;</span>
    </div>
    <div class="metrics-summary-content" id="metricsSummaryContent">
    </div>
    <div class="metrics-summary-footer">
        Powered by Environment Canada Weather Data
    </div>
</div>
<div class="compare-modal" id="compareModal">
    <div class="compare-modal-content">
        <div class="compare-modal-header">
            <h2 class="compare-modal-title">Compare Cities</h2>
            <span class="close-compare-modal">&times;</span>
        </div>
        <div class="compare-modal-body">
            <div class="compare-controls">
                <select class="compare-metric-select" id="compareMetricSelect">
                    <option value="temperature">Temperature (°C)</option>
                    <option value="wind">Wind Speed (km/h)</option>
                    <option value="humidity">Humidity (%)</option>
                    <option value="pressure">Pressure (kPa)</option>
                    <option value="visibility">Visibility (km)</option>
                </select>
                <button class="submit-btn" id="updateCompareBtn">
                    <i class="fas fa-sync-alt"></i> Update Comparison
                </button>
            </div>
            <div class="compare-chart-container">
                <canvas id="compareChart"></canvas>
            </div>
            <div>
                <h3>Select Cities to Compare</h3>
                <div class="compare-city-list" id="compareCityList">
                </div>
            </div>
        </div>
    </div>
</div>
<script>
const tileLayers = {
    'osm': L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
    }),
    'osm-classic': L.tileLayer('https://{s}.tile.openstreetmap.fr/osmfr/{z}/{x}/{y}.png', {
        attribution: '&copy; OpenStreetMap France | &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
    }),
    'osm-humanitarian': L.tileLayer('https://{s}.tile.openstreetmap.fr/hot/{z}/{x}/{y}.png', {
        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors, Tiles courtesy of <a href="https://hot.openstreetmap.org/" target="_blank">Humanitarian OpenStreetMap Team</a>'
    }),
    'carto-positron': L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png', {
        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors, &copy; <a href="https://carto.com/attribution">CARTO</a>'
    }),
    'carto-dark': L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}.png', {
        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors, &copy; <a href="https://carto.com/attribution">CARTO</a>'
    }),
    'esri-imagery': L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
        attribution: 'Tiles &copy; Esri &mdash; Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community'
    }),
    'esri-topo': L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Topo_Map/MapServer/tile/{z}/{y}/{x}', {
        attribution: 'Tiles &copy; Esri &mdash; Esri, DeLorme, NAVTEQ, TomTom, Intermap, iPC, USGS, FAO, NPS, NRCAN, GeoBase, Kadaster NL, Ordnance Survey, Esri Japan, METI, Esri China (Hong Kong), and the GIS User Community'
    })
};
const cityData = {
    ybr: {
        name: "Brandon",
        province: "Manitoba",
        station: "ybr",
        url: "https://weather.gc.ca/past_conditions/index_e.html?station=ybr",
        lat: 49.91,
        lng: -99.95
    },
    yyc: {
        name: "Calgary",
        province: "Alberta",
        station: "yyc",
        url: "https://weather.gc.ca/past_conditions/index_e.html?station=yyc",
        lat: 51.1139,
        lng: -114.0203
    },
    yqg: {
        name: "Bridgewater",
        province: "Nova Scotia",
        station: "yqg",
        url: "https://weather.gc.ca/past_conditions/index_e.html?station=yqg",
        lat: 44.37,
        lng: -64.52
    },
    yyg: {
        name: "Charlottetown",
        province: "Prince Edward Island",
        station: "yyg",
        url: "https://weather.gc.ca/past_conditions/index_e.html?station=yyg",
        lat: 46.2382,
        lng: -63.1311
    },
    yeg: {
        name: "Edmonton",
        province: "Alberta",
        station: "yeg",
        url: "https://weather.gc.ca/past_conditions/index_e.html?station=yeg",
        lat: 53.5461,
        lng: -113.4938
    },
    yfc: {
        name: "Fredericton",
        province: "New Brunswick",
        station: "yfc",
        url: "https://weather.gc.ca/past_conditions/index_e.html?station=yfc",
        lat: 45.9636,
        lng: -66.6431
    },
    yhz: {
        name: "Halifax",
        province: "Nova Scotia",
        station: "yhz",
        url: "https://weather.gc.ca/past_conditions/index_e.html?station=yhz",
        lat: 44.6488,
        lng: -63.5752
    },
    ywk: {
        name: "Labrador City",
        province: "Newfoundland and Labrador",
        station: "ywk",
        url: "https://weather.gc.ca/past_conditions/index_e.html?station=ywk",
        lat: 52.92,
        lng: -66.86
    },
    yxu: {
        name: "London",
        province: "Ontario",
        station: "yxu",
        url: "https://weather.gc.ca/past_conditions/index_e.html?station=yxu",
        lat: 43.0333,
        lng: -81.15
    },
    yul: {
        name: "Montreal",
        province: "Quebec",
        station: "yul",
        url: "https://weather.gc.ca/past_conditions/index_e.html?station=yul",
        lat: 45.4706,
        lng: -73.7408
    },
    yow: {
        name: "Ottawa",
        province: "Ontario",
        station: "yow",
        url: "https://weather.gc.ca/past_conditions/index_e.html?station=yow",
        lat: 45.3225,
        lng: -75.6692
    },
    yqb: {
        name: "Quebec City",
        province: "Quebec",
        station: "yqb",
        url: "https://weather.gc.ca/past_conditions/index_e.html?station=yqb",
        lat: 46.8139,
        lng: -71.2080
    },
    yqr: {
        name: "Regina",
        province: "Saskatchewan",
        station: "yqr",
        url: "https://weather.gc.ca/past_conditions/index_e.html?station=yqr",
        lat: 50.4322,
        lng: -104.666
    },
    ysj: {
        name: "Saint John",
        province: "New Brunswick",
        station: "ysj",
        url: "https://weather.gc.ca/past_conditions/index_e.html?station=ysj",
        lat: 45.3163,
        lng: -65.8903
    },
    yxe: {
        name: "Saskatoon",
        province: "Saskatchewan",
        station: "yxe",
        url: "https://weather.gc.ca/past_conditions/index_e.html?station=yxe",
        lat: 52.1707,
        lng: -106.6997
    },
    wsd: {
        name: "Summerside",
        province: "Prince Edward Island",
        station: "wsd",
        url: "https://weather.gc.ca/past_conditions/index_e.html?station=wsd",
        lat: 46.4406,
        lng: -63.8336
    },
    yyz: {
        name: "Toronto",
        province: "Ontario",
        station: "yyz",
        url: "https://weather.gc.ca/past_conditions/index_e.html?station=yyz",
        lat: 43.6777,
        lng: -79.6248
    },
    yvr: {
        name: "Vancouver",
        province: "British Columbia",
        station: "yvr",
        url: "https://weather.gc.ca/past_conditions/index_e.html?station=yvr",
        lat: 49.1947,
        lng: -123.1794
    },
    yyj: {
        name: "Victoria",
        province: "British Columbia",
        station: "yyj",
        url: "https://weather.gc.ca/past_conditions/index_e.html?station=yyj",
        lat: 48.4284,
        lng: -123.3656
    },
    yxy: {
        name: "Whitehorse",
        province: "Yukon",
        station: "yxy",
        url: "https://weather.gc.ca/past_conditions/index_e.html?station=yxy",
        lat: 60.7212,
        lng: -135.0568
    },
    ywg: {
        name: "Winnipeg",
        province: "Manitoba",
        station: "ywg",
        url: "https://weather.gc.ca/past_conditions/index_e.html?station=ywg",
        lat: 49.8951,
        lng: -97.1384
    },
    yzf: {
        name: "Yellowknife",
        province: "Northwest Territories",
        station: "yzf",
        url: "https://weather.gc.ca/past_conditions/index_e.html?station=yzf",
        lat: 62.4530,
        lng: -114.3718
    }
};
const windDirections = [
    'N', 'NNE', 'NE', 'ENE', 'E', 'ESE', 'SE', 'SSE',
    'S', 'SSW', 'SW', 'WSW', 'W', 'WNW', 'NW', 'NNW'
];
let map;
let tempMarkers = {};
let visualizerModalChart;
let selectedDay = null;
let weatherForecastData = [];
let visualizerChartData = {};
let currentMetric = 'temperature';
let metricNames = {
    temperature: 'Temperature',
    wind: 'Wind Speed',
    humidity: 'Humidity',
    pressure: 'Pressure',
    visibility: 'Visibility'
};
let metricUnits = {
    temperature: { metric: '°C' },
    wind: { metric: 'km/h' },
    humidity: { metric: '%' },
    pressure: { metric: 'kPa' },
    visibility: { metric: 'km' }
};
let compareChart = null;
let selectedCitiesForComparison = ['yqr', 'yyz', 'yvr'];
let currentCityMetrics = {};
/**
 * Initializes the weather dashboard application by:
 * 1. Fetching all city metrics
 * 2. Initializing the map
 * 3. Updating the current date display
 * 4. Loading weather forecast data
 * 5. Setting up the visualizer components
 * 
 * @async
 * @function init
 * @throws {Error} If initialization fails, displays error message to user
 * @returns {Promise<void>} Resolves when initialization is complete
 */
async function init() {
    document.getElementById('loadingOverlay').style.display = 'flex';
    try {
        await fetchAllCityMetrics();
        initMap();
        updateCurrentDate();
        loadWeatherForecast();
        setupVisualizer();
        document.getElementById('loadingOverlay').style.display = 'none';
    } catch (error) {
        console.error('Initialization error:', error);
        document.getElementById('loadingOverlay').innerHTML = `
            <div style="text-align: center; color: var(--danger);">
                <i class="fas fa-exclamation-triangle" style="font-size: 2rem; margin-bottom: 1rem;"></i>
                <p>Failed to load initial weather data. Please refresh the page to try again.</p>
                <button onclick="window.location.reload()" style="margin-top: 1rem; background: var(--primary); color: white; border: none; padding: 0.5rem 1rem; border-radius: 5px; cursor: pointer;">
                    <i class="fas fa-sync-alt"></i> Refresh Page
                </button>
            </div>
        `;
    }
    document.getElementById('prevMetricBtn').addEventListener('click', () => {
        const metrics = Object.keys(metricNames);
        const currentIndex = metrics.indexOf(currentMetric);
        const newIndex = (currentIndex - 1 + metrics.length) % metrics.length;
        setCurrentMetric(metrics[newIndex]);
    });
    document.getElementById('nextMetricBtn').addEventListener('click', () => {
        const metrics = Object.keys(metricNames);
        const currentIndex = metrics.indexOf(currentMetric);
        const newIndex = (currentIndex + 1) % metrics.length;
        setCurrentMetric(metrics[newIndex]);
    });
    document.getElementById('sendEmailBtn').addEventListener('click', function() {
        const eventName = document.getElementById('eventName').value;
        const eventDetails = document.getElementById('eventDetails').value;
        if (!selectedDay) {
            showAlert('Please select a day for your event', 'warning');
            return;
        }
        if (!eventName) {
            showAlert('Please enter an event name', 'warning');
            return;
        }
        const selectedDayElement = document.getElementById(selectedDay);
        const forecastData = JSON.parse(selectedDayElement.dataset.forecast);
        const conditionMap = {
            'sun': 'Sunny',
            'cloud-rain': 'Rainy',
            'snowflake': 'Snow',
            'bolt': 'Thunderstorm',
            'cloud': 'Cloudy',
            'cloud-sun': 'Partly Cloudy',
            'wind': 'Windy',
            'smog': 'Foggy'
        };
        const dayIcon = forecastData.dayForecast.icon;
        const dayCondition = conditionMap[dayIcon] || 'Unknown';
        const nightCondition = forecastData.nightForecast ? 
            conditionMap[forecastData.nightForecast.icon] || 'Unknown' : 
            dayCondition;
        const subject = `Event Plan: ${eventName} on ${forecastData.dayName}`;
        const body = `
**EVENT PLAN**
----------------------------
📅 Event Name: ${eventName}
📆 Planned Day: ${forecastData.dayName}

🌤️ WEATHER FORECAST:
---------------------
☀️ Day: ${dayCondition} | ${forecastData.dayForecast.temp}
🌙 Night: ${nightCondition} | ${forecastData.nightForecast?.temp || forecastData.dayForecast.temp}

📝 DETAILS:
-----------
${eventDetails}

🔍 WEATHER ASSESSMENT:
----------------------
${getWeatherAssessment(forecastData.outdoorScore)}

---
This plan was generated by Weather Event Planner using live data from Environment Canada
`;
        window.location.href = `mailto:?subject=${encodeURIComponent(subject)}&body=${encodeURIComponent(body)}`;
    });
    document.getElementById('weatherPopupClose').addEventListener('click', () => {
        document.getElementById('weatherPopup').style.display = 'none';
    });
    document.getElementById('metricsSummaryClose').addEventListener('click', () => {
        document.getElementById('metricsSummaryPopup').style.display = 'none';
    });
    document.getElementById('compareBtn').addEventListener('click', openCompareModal);
    document.querySelector('.close-compare-modal').addEventListener('click', closeCompareModal);
    document.getElementById('updateCompareBtn').addEventListener('click', updateCompareChart);
    initCityCheckboxes();
}
/**
 * Initializes city checkboxes for the comparison feature by:
 * 1. Creating checkbox elements for each city
 * 2. Setting up event listeners for selection changes
 * 3. Maintaining selected cities state
 * 
 * @function initCityCheckboxes
 * @returns {void}
 */
function initCityCheckboxes() {
    const cityList = document.getElementById('compareCityList');
    cityList.innerHTML = '';
    Object.keys(cityData).forEach(cityKey => {
        const city = cityData[cityKey];
        const checkboxId = `compare-city-${cityKey}`;
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.id = checkboxId;
        checkbox.className = 'compare-city-checkbox';
        checkbox.value = cityKey;
        checkbox.checked = selectedCitiesForComparison.includes(cityKey);
        const label = document.createElement('label');
        label.htmlFor = checkboxId;
        label.className = 'compare-city-label';
        label.textContent = city.name;
        const container = document.createElement('div');
        container.appendChild(checkbox);
        container.appendChild(label);
        cityList.appendChild(container);
        checkbox.addEventListener('change', function() {
            if (this.checked) {
                if (!selectedCitiesForComparison.includes(cityKey)) {
                    selectedCitiesForComparison.push(cityKey);
                }
            } else {
                selectedCitiesForComparison = selectedCitiesForComparison.filter(c => c !== cityKey);
            }
        });
    });
}
/**
 * Opens the city comparison modal and updates the comparison chart
 * 
 * @function openCompareModal
 * @returns {void}
 */
function openCompareModal() {
    document.getElementById('compareModal').style.display = 'flex';
    updateCompareChart();
}
/**
 * Closes the city comparison modal and cleans up chart resources
 * 
 * @function closeCompareModal
 * @returns {void}
 */
function closeCompareModal() {
    document.getElementById('compareModal').style.display = 'none';
    if (compareChart) {
        compareChart.destroy();
        compareChart = null;
    }
}
/**
 * Updates the comparison chart based on selected metric and cities
 * 
 * @function updateCompareChart
 * @returns {void}
 */
function updateCompareChart() {
    const metric = document.getElementById('compareMetricSelect').value;
    const ctx = document.getElementById('compareChart').getContext('2d');
    const citiesToCompare = selectedCitiesForComparison.filter(cityKey => 
        currentCityMetrics[cityKey] && currentCityMetrics[cityKey][getMetricKey(metric)]
    );
    if (citiesToCompare.length === 0) {
        if (compareChart) compareChart.destroy();
        document.getElementById('compareChart').parentElement.innerHTML = `
            <div style="text-align: center; padding: 20px; color: var(--muted);">
                <i class="fas fa-exclamation-circle" style="font-size: 2rem; margin-bottom: 1rem;"></i>
                <p>No data available for selected cities and metric.</p>
                <p>Please select different cities or try another metric.</p>
            </div>
        `;
        return;
    }
    const labels = citiesToCompare.map(cityKey => cityData[cityKey].name);
    const data = citiesToCompare.map(cityKey => {
        const metrics = currentCityMetrics[cityKey];
        return metrics[getMetricKey(metric)];
    });
    const unit = metricUnits[metric].metric;
    const barColor = 'rgba(54, 162, 235, 0.7)';
    const borderColor = 'rgba(54, 162, 235, 1)';
    if (compareChart) {
        compareChart.destroy();
    }
    compareChart = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [{
                label: `${metricNames[metric]} (${unit})`,
                data: data,
                backgroundColor: Array(citiesToCompare.length).fill(barColor),
                borderColor: Array(citiesToCompare.length).fill(borderColor),
                borderWidth: 1
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                title: { 
                    display: true, 
                    text: `Comparison of ${metricNames[metric]} Across Cities`,
                    font: { size: 18 }
                },
                tooltip: {
                    callbacks: {
                        label: function(context) {
                            return `${metricNames[metric]}: ${context.parsed.y.toFixed(1)} ${unit}`;
                        }
                    }
                }
            },
            scales: {
                y: { 
                    beginAtZero: true,
                    title: { 
                        display: true, 
                        text: unit
                    }
                }
            },
            onClick: (e, activeElements) => {
    if (activeElements.length > 0) {
        const clickedIndex = activeElements[0].index;
        const clickedLabel = chartLabels[clickedIndex];
        if (clickedLabel === primaryData.currentHour) {
            const selectedCity = document.getElementById('visualizerCitySelect').value;
            const city = cityData[selectedCity];
            showMetricsSummary(city.name, primaryData.currentHour);
        }
    }
}
        }
    });
}
/**
 * Gets the corresponding metric key from a display metric name
 * 
 * @function getMetricKey
 * @param {string} metric - The display metric name (e.g., 'temperature')
 * @returns {string} The corresponding data key (e.g., 'temperature')
 */
function getMetricKey(metric) {
    switch(metric) {
        case 'temperature': return 'temperature';
        case 'wind': return 'windSpeed';
        case 'humidity': return 'humidity';
        case 'pressure': return 'pressure';
        case 'visibility': return 'visibility';
        default: return 'temperature';
    }
}
/**
 * Sets the current metric being displayed on the map and updates:
 * 1. The legend display
 * 2. All map markers
 * 
 * @function setCurrentMetric
 * @param {string} metric - The metric to display ('temperature', 'wind', etc.)
 * @returns {void}
 */
function setCurrentMetric(metric) {
    currentMetric = metric;
    document.getElementById('currentMetricBtn').textContent = metricNames[metric];
    updateLegend();
    updateMapMarkers();
}
/**
 * Updates the map legend based on the current metric being displayed
 * 
 * @function updateLegend
 * @returns {void}
 */
function updateLegend() {
    const legendTitle = document.getElementById('metricLegendTitle');
    const legendScale = document.getElementById('metricLegendScale');
    const legendLabels = document.getElementById('metricLegendLabels');
    switch(currentMetric) {
        case 'temperature':
            legendTitle.textContent = `Temperature (°C)`;
            legendScale.style.background = 'linear-gradient(to right, #3498db, #b6bcb9, #e74c3c)';
            legendLabels.innerHTML = `
                <div class="metric-legend-label">-20°</div>
                <div class="metric-legend-label">0°</div>
                <div class="metric-legend-label">20°</div>
            `;
            break;
        case 'wind':
            legendTitle.textContent = `Wind Speed (km/h)`;
            legendScale.style.background = 'linear-gradient(to right, #aed6f1, #85c1e9, #5dade2, #3498db, #2874a6, #1a5276)';
            legendLabels.innerHTML = `
                <div class="metric-legend-label">0</div>
                <div class="metric-legend-label">10</div>
                <div class="metric-legend-label">20</div>
                <div class="metric-legend-label">30</div>
                <div class="metric-legend-label">40</div>
                <div class="metric-legend-label">50</div>
            `;
            break;
        case 'humidity':
            legendTitle.textContent = 'Humidity (%)';
            legendScale.style.background = 'linear-gradient(to right, #abebc6, #58d68d, #28b463, #1d8348)';
            legendLabels.innerHTML = `
                <div class="metric-legend-label">0</div>
                <div class="metric-legend-label">30</div>
                <div class="metric-legend-label">60</div>
                <div class="metric-legend-label">90</div>
            `;
            break;
        case 'pressure':
            legendTitle.textContent = `Pressure (kPa)`;
            legendScale.style.background = 'linear-gradient(to right, #bb8fce, #8e44ad, #6c3483)';
            legendLabels.innerHTML = `
                <div class="metric-legend-label">96</div>
                <div class="metric-legend-label">100</div>
                <div class="metric-legend-label">104</div>
            `;
            break;
        case 'visibility':
            legendTitle.textContent = `Visibility (km)`;
            legendScale.style.background = 'linear-gradient(to right, #f8c471, #f39c12, #d68910, #b9770e)';
            legendLabels.innerHTML = `
                <div class="metric-legend-label">0</div>
                <div class="metric-legend-label">5</div>
                <div class="metric-legend-label">10</div>
                <div class="metric-legend-label">20</div>
            `;
            break;
    }
}
/**
 * Fetches weather metrics for all cities from the API
 * 
 * @async
 * @function fetchAllCityMetrics
 * @returns {Promise<void>} Resolves when all city metrics are fetched
 */
async function fetchAllCityMetrics() {
    const cityKeys = Object.keys(cityData);
    const fetchPromises = cityKeys.map(async cityKey => {
        const city = cityData[cityKey];
        try {
            const metrics = await fetchCityMetrics(city);
            currentCityMetrics[cityKey] = metrics;
            return { cityKey, metrics, success: true };
        } catch (error) {
            console.error(`Failed to fetch metrics for ${city.name}:`, error);
            const fallbackMetrics = getFallbackMetrics(city.lat);
            currentCityMetrics[cityKey] = fallbackMetrics;
            return { cityKey, metrics: fallbackMetrics, success: false };
        }
    });
    const results = await Promise.all(fetchPromises);
    results.forEach(result => {
        if (!result.success) {
            console.warn(`Used fallback metrics for ${cityData[result.cityKey].name}`);
        }
    });
}
/**
 * Fetches weather metrics for a specific city from the API
 * 
 * @async
 * @function fetchCityMetrics
 * @param {Object} city - The city object containing URL and location data
 * @throws {Error} If the API request fails or data is invalid
 * @returns {Promise<Object>} Resolves with the city's weather metrics
 */
async function fetchCityMetrics(city) {
    const proxyUrl = 'https://api.allorigins.win/raw?url=';
    const targetUrl = city.url;
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 10000);
    const response = await fetch(proxyUrl + encodeURIComponent(targetUrl), {
        signal: controller.signal
    });
    clearTimeout(timeoutId);
    if (!response.ok) throw new Error('Network response was not ok');
    const html = await response.text();
    const parser = new DOMParser();
    const doc = parser.parseFromString(html, 'text/html');
    const table = doc.querySelector('table.table-striped');
    if (!table) throw new Error('Weather table not found in the response');
    const tableClone = table.cloneNode(true);
    tableClone.querySelectorAll('img').forEach(img => img.remove());
    return extractCityMetrics(tableClone);
}
/**
 * Extracts weather metrics from an HTML table element
 * 
 * @function extractCityMetrics
 * @param {HTMLElement} table - The HTML table element containing weather data
 * @returns {Object} An object containing extracted weather metrics
 */
function extractCityMetrics(table) {
    const headers = Array.from(table.querySelectorAll('thead th')).map(th => th.textContent.trim());
    const rows = Array.from(table.querySelectorAll('tbody tr'));
    const currentHour = new Date().getHours().toString().padStart(2, '0') + ":00";
    const currentRow = rows.find(row => 
        row.querySelector('td')?.textContent.trim() === currentHour
    )
    if (!currentRow) throw new Error('No data rows found');
    const cells = Array.from(currentRow.querySelectorAll('td'));
    const extractValue = (headerText) => {
        const index = headers.findIndex(h => h.includes(headerText));
        if (index === -1) return null;
        const cellText = cells[index]?.textContent.trim();
        if (!cellText) return null;
        const match = cellText.match(/-?\d+\.?\d*/);
        return match ? parseFloat(match[0]) : null;
    };
    const metrics = {
        temperature: extractValue('Temperature') || getFallbackTemperature(city.lat),
        windSpeed: extractValue('Wind Speed') || getRandomInRange(5, 20),
        humidity: extractValue('Humidity') || getRandomInRange(30, 80),
        pressure: extractValue('Pressure') || getRandomInRange(98, 102),
        visibility: extractValue('Visibility') || getRandomInRange(5, 20)
    };
    return metrics;
}
/**
 * Generates fallback weather metrics when API data is unavailable
 * 
 * @function getFallbackMetrics
 * @param {number} latitude - The latitude of the location
 * @returns {Object} An object containing generated weather metrics
 */
function getFallbackMetrics(latitude) {
    return {
        temperature: getFallbackTemperature(latitude),
        windSpeed: getRandomInRange(5, 20),
        humidity: getRandomInRange(30, 80),
        pressure: getRandomInRange(98, 102),
        visibility: getRandomInRange(5, 20)
    };
}
/**
 * Generates a temperature value based on latitude when API data is unavailable
 * 
 * @function getFallbackTemperature
 * @param {number} latitude - The latitude of the location
 * @returns {number} A generated temperature value
 */
function getFallbackTemperature(latitude) {
    const baseTemp = 10;
    const latDiff = latitude - 45;
    return baseTemp - latDiff;
}
/**
 * Generates a random number within a specified range
 * 
 * @function getRandomInRange
 * @param {number} min - The minimum value
 * @param {number} max - The maximum value
 * @returns {number} A random number between min and max
 */
function getRandomInRange(min, max) {
    return Math.random() * (max - min) + min;
}
/**
 * Initializes the Leaflet map with default settings and layers
 * 
 * @function initMap
 * @returns {void}
 */
function initMap() {
    map = L.map('map', {
        minZoom: 2,
        maxZoom: 18
    }).setView([50.4322, -104.666], 4);
    tileLayers.osm.addTo(map);
    document.getElementById('mapLayerSelect').addEventListener('change', function() {
        const layerKey = this.value;
        Object.values(tileLayers).forEach(layer => map.removeLayer(layer));
        tileLayers[layerKey].addTo(map);
    });
    plotCityPoints();
}
/**
 * Plots all city points on the map with current weather data
 * 
 * @function plotCityPoints
 * @returns {void}
 */
function plotCityPoints() {
    Object.keys(cityData).forEach(cityKey => {
        createOrUpdateMarker(cityKey);
    });
}
/**
 * Creates or updates a map marker for a specific city with current weather data
 * 
 * @function createOrUpdateMarker
 * @param {string} cityKey - The key identifying the city in cityData
 * @returns {void}
 */
function createOrUpdateMarker(cityKey) {
    const city = cityData[cityKey];
    const metrics = currentCityMetrics[cityKey];
    if (!metrics) return;
    let value, metricClass, displayValue;
    switch(currentMetric) {
        case 'temperature':
            value = metrics.temperature;
            displayValue = value;
            if (value <= 0) metricClass = 'temp-negative';
            else if (value <= 10) metricClass = 'temp-zero';
            else metricClass = 'temp-positive';
            break;
        case 'wind':
            value = metrics.windSpeed;
            displayValue = value;
            if (value <= 10) metricClass = 'wind-storm';
            else if (value <= 20) metricClass = 'wind-gale';
            else if (value <= 30) metricClass = 'wind-strong';
            else if (value <= 40) metricClass = 'wind-moderate';
            else if (value <= 50) metricClass = 'wind-light';
            else metricClass = 'wind-calm';
            break;
        case 'humidity':
            value = metrics.humidity;
            displayValue = value;
            if (value <= 30) metricClass = 'humid-very-humid';
            else if (value <= 60) metricClass = 'humid-humid';
            else if (value <= 90) metricClass = 'humid-comfortable';
            else metricClass = 'humid-dry';
            break;
        case 'pressure':
            value = metrics.pressure;
            displayValue = value;
            if (value < 98) metricClass = 'pressure-high';
            else if (value <= 102) metricClass = 'pressure-normal';
            else metricClass = 'pressure-low';
            break;
        case 'visibility':
            value = metrics.visibility;
            displayValue = value;
            if (value < 1) metricClass = 'visibility-excellent';
            else if (value <= 5) metricClass = 'visibility-good';
            else if (value <= 10) metricClass = 'visibility-moderate';
            else metricClass = 'visibility-poor';
            break;
    }
    const metricIcon = L.divIcon({
        className: `metric-point ${metricClass}`,
        html: `<span>${Math.round(displayValue)}</span>`,
        iconSize: [38, 38]
    });
    if (tempMarkers[cityKey]) {
        map.removeLayer(tempMarkers[cityKey]);
    }
    const marker = L.marker([city.lat, city.lng], {
        icon: metricIcon
    }).addTo(map);
    const unit = metricUnits[currentMetric].metric;
    marker.bindTooltip(`
        <b>${city.name}, ${city.province}</b><br>
        ${metricNames[currentMetric]}: ${displayValue.toFixed(1)}${unit}<br>
        <small>Click for detailed weather</small>
    `);
    marker.on('click', function() {
        document.getElementById('visualizerCitySelect').value = cityKey;
        fetchVisualizerData();
        map.setView([city.lat, city.lng], 10);
    });
    tempMarkers[cityKey] = marker;
}
/**
 * Updates all map markers with current weather data
 * 
 * @function updateMapMarkers
 * @returns {void}
 */
function updateMapMarkers() {
    Object.keys(tempMarkers).forEach(cityKey => {
        createOrUpdateMarker(cityKey);
    });
}
/**
 * Sets up the visualizer component with event listeners and initial data
 * 
 * @function setupVisualizer
 * @returns {void}
 */
function setupVisualizer() {
    document.getElementById('visualizerFetchBtn').addEventListener('click', fetchVisualizerData);
    document.getElementById('visualizerCitySelect').addEventListener('change', function() {
        const selectedCity = this.value;
        const city = cityData[selectedCity];
        if (city && city.lat && city.lng) {
            map.setView([city.lat, city.lng], 10);
        }
        loadWeatherForecast();
        fetchVisualizerData();
    });
    document.querySelector('.close-modal').addEventListener('click', closeVisualizerModal);
    window.addEventListener('click', (event) => {
        if (event.target === document.getElementById('visualizerModal')) {
            closeVisualizerModal();
        }
        if (event.target === document.getElementById('weatherPopup')) {
            document.getElementById('weatherPopup').style.display = 'none';
        }
        if (event.target === document.getElementById('metricsSummaryPopup')) {
            document.getElementById('metricsSummaryPopup').style.display = 'none';
        }
        if (event.target === document.getElementById('compareModal')) {
            closeCompareModal();
        }
    });
    fetchVisualizerData();
}
/**
 * Fetches weather data for the currently selected city in the visualizer
 * 
 * @async
 * @function fetchVisualizerData
 * @returns {Promise<void>} Resolves when data is fetched and processed
 */
async function fetchVisualizerData() {
    const fetchBtn = document.getElementById('visualizerFetchBtn');
    const loadingElement = document.getElementById('visualizerLoading');
    const errorElement = document.getElementById('visualizerError');
    const citySelect = document.getElementById('visualizerCitySelect');
    errorElement.style.display = 'none';
    loadingElement.style.display = 'flex';
    fetchBtn.disabled = true;
    document.getElementById('visualizerGrid').innerHTML = '';
    visualizerChartData = {};
    const selectedCity = citySelect.value;
    const city = cityData[selectedCity];
    try {
        const proxyUrl = 'https://api.allorigins.win/raw?url=';
        const targetUrl = city.url;
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 10000);
        const response = await fetch(proxyUrl + encodeURIComponent(targetUrl), {
            signal: controller.signal
        });
        clearTimeout(timeoutId);
        if (!response.ok) throw new Error('Network response was not ok');
        const html = await response.text();
        const parser = new DOMParser();
        const doc = parser.parseFromString(html, "text/html");
        const table = doc.querySelector('table.table-striped');
        if (table) {
            const tableClone = table.cloneNode(true);
            tableClone.querySelectorAll('img').forEach(img => img.remove());
            processAndCreateVisualizerCards(tableClone, city.name);
            const metrics = extractCityMetrics(tableClone);
            if (metrics) {
                currentCityMetrics[selectedCity] = metrics;
                createOrUpdateMarker(selectedCity);
            }
        } else {
            throw new Error('Weather table not found in the response');
        }
    } catch (error) {
        errorElement.textContent = `Error loading data for ${city.name}: ${error.message}`;
        errorElement.style.display = 'block';
        console.error('Fetch error:', error);
    } finally {
        loadingElement.style.display = 'none';
        fetchBtn.disabled = false;
    }
}
/**
 * Processes weather table data and creates visualizer cards for each metric
 * 
 * @function processAndCreateVisualizerCards
 * @param {HTMLElement} table - The HTML table element containing weather data
 * @param {string} cityName - The name of the city being displayed
 * @returns {void}
 */
function processAndCreateVisualizerCards(table, cityName) {
    const headers = Array.from(table.querySelectorAll('thead th')).map(th => {
        let text = th.textContent.trim();
        if (text.includes('Temperature') && text.includes('°C')) {
            text = 'Temperature (°C)';
        } else if (text.includes('Temperature') && text.includes('°F')) {
            text = 'Temperature (°F)';
        } else if (text.includes('Wind') && text.includes('km/h')) {
            text = 'Wind Speed (km/h)';
        } else if (text.includes('Wind') && text.includes('mph')) {
            text = 'Wind Speed (mph)';
        } else if (text.includes('Humidity')) {
            text = 'Humidity (%)';
        } else if (text.includes('Pressure') && text.includes('kPa')) {
            text = 'Pressure (kPa)';
        } else if (text.includes('Pressure') && text.includes('in')) {
            text = 'Pressure (inHg)';
        } else if (text.includes('Visibility') && text.includes('km')) {
            text = 'Visibility (km)';
        } else if (text.includes('Visibility') && text.includes('mi')) {
            text = 'Visibility (mi)';
        }
        return text;
    });
    const rows = Array.from(table.querySelectorAll('tbody tr'));
    const data = rows.map(row => 
        Array.from(row.querySelectorAll('td')).map(td => {
            const text = td.textContent.trim();
            if (text.includes('/')) {
                const parts = text.split('/').map(part => parseFloat(part));
                if (parts.every(num => !isNaN(num))) {
                    return parts.reduce((a, b) => a + b) / parts.length;
                }
            }
            return text;
        })
    );
    
    const currentHour = new Date().getHours().toString().padStart(2, '0') + ":00";
    const currentRow = data.find(row => row[0] === currentHour);
    
    if (!currentRow) {
        document.getElementById('visualizerGrid').innerHTML = 
            `<div class="no-visuals">No data available for current hour (${currentHour}) in ${cityName}</div>`;
        return;
    }
    
    const metricGroups = {};
    
    headers.forEach((header, colIndex) => {
        if (colIndex === 0) return;
        
        const metricType = header.replace(/\([^)]+\)/, '').trim();
        const unitMatch = header.match(/\(([^)]+)\)/);
        const unit = unitMatch ? unitMatch[1] : '';
        
        if (!metricGroups[metricType]) {
            metricGroups[metricType] = {
                metricName: metricType,
                values: {}
            };
        }
        
        const allValues = data.map(row => {
            const text = row[colIndex];
            if (typeof text === 'number') return text;
            if (!text || typeof text !== 'string') return null;
            const match = text.match(/-?\d+\.?\d*/);
            return match ? parseFloat(match[0]) : null;
        }).filter(v => v !== null);
        
        if (allValues.length === 0) return;
        
        const currentValue = (() => {
            const text = currentRow[colIndex];
            if (typeof text === 'number') return text;
            if (!text || typeof text !== 'string') return null;
            const match = text.match(/-?\d+\.?\d*/);
            return match ? parseFloat(match[0]) : null;
        })();
        
        if (currentValue === null || currentValue === undefined) return;
        
        metricGroups[metricType].values[unit] = {
            labels: data.map(row => row[0] || ''),
            values: allValues,
            currentValue: currentValue,
            unit: unit,
            currentHour: currentHour
        };
    });
    
    Object.keys(metricGroups).forEach(metricType => {
        const group = metricGroups[metricType];
        const metricValues = group.values;
        const metricUnits = Object.keys(metricValues);
        
        if (metricUnits.length === 0) return;

        let primaryUnit = metricUnits.find(u => 
            u.includes('°C') || u.includes('km/h') || u.includes('kPa') || u.includes('km')
        ) || metricUnits[0];
        
        const primaryData = metricValues[primaryUnit];
        const imperialData = metricUnits.find(u => u !== primaryUnit) ? 
            metricValues[metricUnits.find(u => u !== primaryUnit)] : null;
        
        if (document.querySelector(`[data-metric="${metricType}"]`)) {
            return;
        }
        
        const card = document.createElement('div');
        card.className = 'visual-card';
        card.setAttribute('data-metric', metricType);
        
        let imperialValueHtml = '';
        if (imperialData) {
            imperialValueHtml = `
                <div class="current-value-imperial">${imperialData.currentValue.toFixed(1)}</div>
                <div class="unit-imperial">${imperialData.unit}</div>
            `;
        }
        
        card.innerHTML = `
    <div class="visual-card-header">
        <h3 title="${metricType}">${metricType}</h3>
        <div class="value-container">
            <div class="current-value">${primaryData.currentValue.toFixed(1)}</div>
            <div class="unit">${primaryData.unit}</div>
            ${imperialData ? `
            <div class="imperial-container">
                <div class="current-value-imperial">${imperialData.currentValue.toFixed(1)}</div>
                <div class="unit-imperial">${imperialData.unit}</div>
            </div>
            ` : ''}
        </div>
        <div class="sparkline-container">
            <canvas id="sparkline-${metricType.replace(/[^a-zA-Z0-9]/g, '-')}"></canvas>
        </div>
    </div>
`;
        
        card.addEventListener('click', () => {
            openVisualizerModal(metricType, primaryData, imperialData, cityName);
        });
        
        document.getElementById('visualizerGrid').appendChild(card);
        
        createSparklineChart(
            `sparkline-${metricType.replace(/[^a-zA-Z0-9]/g, '-')}`,
            primaryData.values.slice(-24),
            primaryData.currentValue,
            metricType.includes('Temperature') ? '#e74c3c' : 
            metricType.includes('Wind') ? '#3498db' : 
            metricType.includes('Humidity') ? '#28b463' : 
            metricType.includes('Pressure') ? '#8e44ad' : 
            metricType.includes('Visibility') ? '#f39c12' : '#4361ee'
        );
    });
    
    if (Object.keys(metricGroups).length === 0) {
        document.getElementById('visualizerGrid').innerHTML = 
            `<div class="no-visuals">No numeric data found for current hour (${currentHour}) in ${cityName}</div>`;
    }
}
/**
 * Creates a sparkline chart for a weather metric
 * 
 * @function createSparklineChart
 * @param {string} canvasId - The ID of the canvas element
 * @param {Array<number>} values - The data values to display
 * @param {number} currentValue - The current value to highlight
 * @param {string} color - The color for the sparkline
 * @returns {void}
 */
function createSparklineChart(canvasId, values, currentValue, color) {
    const canvas = document.getElementById(canvasId);
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    const container = canvas.parentElement;
    canvas.width = container.clientWidth;
    canvas.height = container.clientHeight;
    const padding = 2;
    const chartWidth = canvas.width - padding * 2;
    const chartHeight = canvas.height - padding * 2;
    const min = Math.min(...values);
    const max = Math.max(...values);
    const range = max - min || 1;
    const reversedValues = [...values].reverse();
    const normalizedValues = reversedValues.map(v => {
        return ((v - min) / range) * chartHeight;
    });
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.beginPath();
    ctx.moveTo(padding, padding + chartHeight - normalizedValues[0]);
    const step = chartWidth / (normalizedValues.length - 1);
    for (let i = 1; i < normalizedValues.length; i++) {
        ctx.lineTo(padding + i * step, padding + chartHeight - normalizedValues[i]);
    }
    ctx.strokeStyle = color;
    ctx.lineWidth = 2;
    ctx.stroke();
}
/**
 * Opens the detailed visualizer modal for a specific weather metric
 * 
 * @function openVisualizerModal
 * @param {string} metricName - The name of the metric being displayed
 * @param {Object} primaryData - The primary metric data (metric units)
 * @param {Object|null} imperialData - The imperial units data (if available)
 * @param {string} cityName - The name of the city being displayed
 * @returns {void}
 */
function openVisualizerModal(metricName, primaryData, imperialData, cityName) {
    document.getElementById('visualizerModalTitle').textContent = 
        `${metricName} - ${cityName} at ${primaryData.currentHour} till next hour`;
    
    document.getElementById('visualizerModalCurrentValue').textContent = 
        `${primaryData.currentValue.toFixed(1)} ${primaryData.unit}` + 
        (imperialData ? ` | ${imperialData.currentValue.toFixed(1)} ${imperialData.unit}` : '');
    
    const ctx = document.getElementById('visualizerModalChart').getContext('2d');
    
    if (visualizerModalChart) {
        visualizerModalChart.destroy();
    }
    
    let chartData = [...primaryData.values].reverse();
    let chartLabels = [...primaryData.labels].reverse();
    
    if (chartLabels.length > 0) {
        chartLabels.shift();
    }
    
    const midnightIndex = chartLabels.findIndex(label => label === '00:00');
    const currentIndex = chartLabels.indexOf(primaryData.currentHour);
    
    const backgroundColors = chartLabels.map((labels, index) => 
        index === currentIndex ? 'rgba(255, 87, 34, 0.7)' : 'rgba(0, 150, 136, 0.7)'
    );
    
    if (chartData.length === 0) {
        chartData = Array(chartLabels.length).fill(0);
        backgroundColors.fill('rgba(200, 200, 200, 0.7)');
    }
    
    visualizerModalChart = new Chart(ctx, {
        type: 'line',
        data: {
            labels: chartLabels,
            datasets: [{
                label: metricName,
                data: chartData,
                backgroundColor: backgroundColors,
                borderColor: backgroundColors.map(color => color.replace('0.7', '1')),
                borderWidth: 1
            }]
        },
        options: {
            onHover: (event, chartElements) => {
        const canvas = event.native.target;
        if (chartElements.length > 0) {
            const element = chartElements[0];
            const clickedLabel = chartLabels[element.index];
            if (clickedLabel === primaryData.currentHour) {
                canvas.style.cursor = 'pointer'; 
            } else {
                canvas.style.cursor = 'default'; 
            }
        } else {
            canvas.style.cursor = 'default'; 
        }
    },
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                title: { 
                    display: true, 
                    text: `${metricName} (${primaryData.unit}) - ${cityName}`,
                    font: { size: 22 }
                },
                legend: {
                    display: false,
                },
                tooltip: {
                    bodyFont: {
                size: 16  
            },
            titleFont: {
                size: 16 
            },
                    callbacks: {
                        label: function(context) {
                            return `${metricName}: ${context.parsed.y.toFixed(1)} ${primaryData.unit}`;
                        }
                    }
                },
                annotation: {
                    annotations: {
                        line1: {
                            type: 'line',
                            yMin: primaryData.currentValue,
                            yMax: primaryData.currentValue,
                            borderColor: 'rgb(255, 99, 132)',
                            borderWidth: 2,
                            borderDash: [6, 6],
                        },
                        midnightLine: {
                            type: 'line',
                            xMin: midnightIndex !== -1 ? midnightIndex : 0,
                            xMax: midnightIndex !== -1 ? midnightIndex : 0,
                            borderColor: 'rgb(20, 20, 20)',
                            borderWidth: 1,
                        }
                    }
                }
            },
            scales: {
                y: { 
                    beginAtZero: true,
                    title: { 
                        display: true, 
                        text: primaryData.unit,
                        font: {
                    size: 16,  
                    weight: 'bold'
                }
                    },
                    ticks: {
                font: {
                    size: 14,  
                    weight: 'bold'
                }
            }
                },
                x: {
                    title: { display: true, text: 'Time',font: {
                    size: 16,  
                    weight: 'bold'
                } },
                    offset: true,
                    ticks: {
                        font: {
                    size: 14,  
                    weight: 'bold'
                },
                        autoSkip: false,
                        callback: function(value) {
                            return this.getLabelForValue(value);
                            return value === "" ? null : value;
                        }
                    }
                }
            },
            onClick: (e, activeElements) => {
                if (activeElements.length > 0) {
                    const clickedIndex = activeElements[0].index;
                    const clickedLabel = chartLabels[clickedIndex];
                    if (clickedLabel === primaryData.currentHour) {
                        showMetricsSummary(cityName, primaryData.currentHour);
                    }
                }
            }
        }
    });
    
    document.getElementById('visualizerModal').style.display = 'flex';
}
/**
 * Displays a summary popup with all weather metrics for a city at a specific time
 * 
 * @function showMetricsSummary
 * @param {string} cityName - The name of the city
 * @param {string} currentHour - The hour being displayed (e.g., "12:00")
 * @returns {void}
 */
/**
 * Displays a summary popup with all weather metrics for a city at a specific time
 * 
 * @function showMetricsSummary
 * @param {string} cityName - The name of the city
 * @param {string} currentHour - The hour being displayed (e.g., "12:00")
 * @returns {void}
 */
 function showMetricsSummary(cityName, currentHour) {
    const popup = document.getElementById('metricsSummaryPopup');
    const popupTitle = document.getElementById('metricsSummaryTitle');
    const popupContent = document.getElementById('metricsSummaryContent');
    
    
    const selectedCity = document.getElementById('visualizerCitySelect').value;
    const city = cityData[selectedCity];
    
    
    const metrics = currentCityMetrics[selectedCity];
    
    if (!metrics) {
        popupContent.innerHTML = `
            <div style="text-align: center; padding: 20px; color: var(--danger);">
                <i class="fas fa-exclamation-circle"></i>
                <p>No current weather data available for ${cityName}</p>
            </div>
        `;
        popup.style.display = 'block';
        return;
    }

    popupTitle.textContent = `${cityName} Weather Metrics at ${currentHour}`;
    
    let contentHTML = `
        <div class="metrics-summary-row">
            <div class="metrics-summary-icon">
                <i class="fas fa-temperature-low"></i>
            </div>
            <div class="metrics-summary-details">
                <div class="metrics-summary-label">Temperature</div>
                <div class="metrics-summary-value">${metrics.temperature.toFixed(1)} °C</div>
            </div>
        </div>
        <div class="metrics-summary-row">
            <div class="metrics-summary-icon">
                <i class="fas fa-wind"></i>
            </div>
            <div class="metrics-summary-details">
                <div class="metrics-summary-label">Wind Speed</div>
                <div class="metrics-summary-value">${metrics.windSpeed.toFixed(1)} km/h</div>
            </div>
        </div>
        <div class="metrics-summary-row">
            <div class="metrics-summary-icon">
                <i class="fas fa-tint"></i>
            </div>
            <div class="metrics-summary-details">
                <div class="metrics-summary-label">Humidity</div>
                <div class="metrics-summary-value">${metrics.humidity.toFixed(1)} %</div>
            </div>
        </div>
        <div class="metrics-summary-row">
            <div class="metrics-summary-icon">
                <i class="fas fa-tachometer-alt"></i>
            </div>
            <div class="metrics-summary-details">
                <div class="metrics-summary-label">Pressure</div>
                <div class="metrics-summary-value">${metrics.pressure.toFixed(1)} kPa</div>
            </div>
        </div>
        <div class="metrics-summary-row">
            <div class="metrics-summary-icon">
                <i class="fas fa-eye"></i>
            </div>
            <div class="metrics-summary-details">
                <div class="metrics-summary-label">Visibility</div>
                <div class="metrics-summary-value">${metrics.visibility.toFixed(1)} km</div>
            </div>
        </div>
    `;
    
    popupContent.innerHTML = contentHTML;
    popup.style.display = 'block';
}
/**
 * Closes the visualizer modal and cleans up chart resources
 * 
 * @function closeVisualizerModal
 * @returns {void}
 */
function closeVisualizerModal() {
    document.getElementById('visualizerModal').style.display = 'none';
    if (visualizerModalChart) {
        visualizerModalChart.destroy();
        visualizerModalChart = null;
    }
}
/**
 * Updates the current date display in the dashboard
 * 
 * @function updateCurrentDate
 * @returns {void}
 */
function updateCurrentDate() {
    const date = new Date();
    const options = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' };
    document.getElementById('currentDate').textContent = date.toLocaleDateString('en-CA', options);
}
/**
 * Loads weather forecast data for the selected city
 * 
 * @async
 * @function loadWeatherForecast
 * @returns {Promise<void>} Resolves when forecast data is loaded
 */
async function loadWeatherForecast() {
    let rssUrl = 'https://weather.gc.ca/rss/city/sk-32_e.xml';
    const selectedCity = document.getElementById('visualizerCitySelect').value;
    const city = cityData[selectedCity];
    switch(selectedCity) {
        case 'yfc': rssUrl = 'https://weather.gc.ca/rss/city/nb-29_e.xml'; break;
        case 'yhz': rssUrl = 'https://weather.gc.ca/rss/city/ns-19_e.xml'; break;
        case 'yeg': rssUrl = 'https://weather.gc.ca/rss/city/ab-50_e.xml'; break;
        case 'yyc': rssUrl = 'https://weather.gc.ca/rss/city/ab-52_e.xml'; break;
        case 'yvr': rssUrl = 'https://weather.gc.ca/rss/city/bc-74_e.xml'; break;
        case 'yyj': rssUrl = 'https://weather.gc.ca/rss/city/bc-85_e.xml'; break;
        case 'ybr': rssUrl = 'https://weather.gc.ca/rss/city/mb-52_e.xml'; break;
        case 'ywg': rssUrl = 'https://weather.gc.ca/rss/city/mb-38_e.xml'; break;
        case 'ysj': rssUrl = 'https://weather.gc.ca/rss/city/nb-23_e.xml'; break;
        case 'ywk': rssUrl = 'https://weather.gc.ca/rss/city/nl-20_e.xml'; break;
        case 'yqg': rssUrl = 'https://weather.gc.ca/rss/city/ns-6_e.xml'; break;
        case 'yzf': rssUrl = 'https://weather.gc.ca/rss/city/nt-24_e.xml'; break;
        case 'yxu': rssUrl = 'https://weather.gc.ca/rss/city/on-137_e.xml'; break;
        case 'yow': rssUrl = 'https://weather.gc.ca/rss/city/on-118_e.xml'; break;
        case 'yyz': rssUrl = 'https://weather.gc.ca/rss/city/on-143_e.xml'; break;
        case 'wsd': rssUrl = 'https://weather.gc.ca/rss/city/pe-3_e.xml'; break;
        case 'yyg': rssUrl = 'https://weather.gc.ca/rss/city/pe-5_e.xml'; break;
        case 'yqb': rssUrl = 'https://weather.gc.ca/rss/city/qc-133_e.xml'; break;
        case 'yul': rssUrl = 'https://weather.gc.ca/rss/city/qc-147_e.xml'; break;
        case 'yxe': rssUrl = 'https://weather.gc.ca/rss/city/sk-40_e.xml'; break;
        case 'yqr': rssUrl = 'https://weather.gc.ca/rss/city/sk-32_e.xml'; break;
        case 'yxy': rssUrl = 'https://weather.gc.ca/rss/city/yt-16_e.xml'; break;
    }
    const proxyUrl = 'https://api.allorigins.win/get?url=' + encodeURIComponent(rssUrl);
    const weekDaysContainer = document.getElementById('weekDays');
    const loadingElement = document.getElementById('eventPlannerLoading');
    try {
        const response = await fetch(proxyUrl);
        if (!response.ok) throw new Error('Network response was not ok');
        const data = await response.json();
        if (data.contents) {
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(data.contents, "text/xml");
            weatherForecastData = parseWeatherData(xmlDoc);
            renderWeatherDays(weatherForecastData);
            loadingElement.style.display = 'none';
            weekDaysContainer.style.display = 'grid';
        } else {
            throw new Error('No content received');
        }
    } catch (error) {
        console.error('Error:', error);
        loadingElement.innerHTML = `
            <i class="fas fa-exclamation-triangle" style="font-size: 1.5rem; margin-bottom: 0.5rem; color: var(--danger);"></i>
            <p>Failed to load weather data. Please try again later.</p>
            <button onclick="loadWeatherForecast()" style="margin-top: 0.5rem; background: var(--primary); color: white; border: none; padding: 0.3rem 0.8rem; border-radius: 5px; cursor: pointer;">
                <i class="fas fa-sync-alt"></i> Retry
            </button>
        `;
    }
}
/**
 * Parses weather forecast data from an XML document
 * 
 * @function parseWeatherData
 * @param {Document} xmlDoc - The XML document containing forecast data
 * @returns {Array<Object>} An array of parsed forecast objects
 */
function parseWeatherData(xmlDoc) {
    const entries = xmlDoc.querySelectorAll('entry');
    const forecasts = [];
    entries.forEach(entry => {
        const category = entry.querySelector('category');
        if (category && category.getAttribute('term') === 'Weather Forecasts') {
            const title = entry.querySelector('title').textContent;
            const summary = entry.querySelector('summary').textContent;
            const titleParts = title.split(':');
            const time = titleParts[0].trim();
            const forecastText = titleParts[1].trim();
            let temp = '';
            const tempMatch = forecastText.match(/(High|Low) (plus |minus )?(-?\d+)/i);
            if (tempMatch) {
                temp = (tempMatch[2] === 'minus ' ? '-' : '') + tempMatch[3] + '°C';
            }
            const icon = getWeatherIcon(forecastText, summary);
            const outdoorScore = calculateOutdoorScore(forecastText, summary);
            forecasts.push({
                time,
                temp,
                icon,
                outdoorScore,
                forecastText,
                fullSummary: summary
            });
        }
    });
    return forecasts;
}
/**
 * Determines the appropriate weather icon based on forecast text
 * 
 * @function getWeatherIcon
 * @param {string} forecastText - The forecast text description
 * @param {string} summary - Additional forecast details
 * @returns {string} The Font Awesome icon class name
 */
function getWeatherIcon(forecastText, summary) {
    const text = (forecastText + ' ' + summary).toLowerCase();
    if (text.includes('sunny') || text.includes('clear')) return 'sun';
    if (text.includes('rain') || text.includes('shower')) return 'cloud-rain';
    if (text.includes('snow') || text.includes('flurries')) return 'snowflake';
    if (text.includes('thunder') || text.includes('lightning')) return 'bolt';
    if (text.includes('cloudy')) return 'cloud';
    if (text.includes('partly cloudy') || text.includes('mix of sun and cloud')) return 'cloud-sun';
    if (text.includes('windy')) return 'wind';
    if (text.includes('fog')) return 'smog';
    return 'cloud';
}
/**
 * Calculates an outdoor activity score based on forecast conditions
 * 
 * @function calculateOutdoorScore
 * @param {string} forecastText - The forecast text description
 * @param {string} summary - Additional forecast details
 * @returns {number} A score from 0-100 representing outdoor suitability
 */
function calculateOutdoorScore(forecastText, summary) {
    const text = (forecastText + ' ' + summary).toLowerCase();
    let score = 50;
    if (text.includes('sunny') || text.includes('clear')) score += 30;
    if (text.includes('partly cloudy')) score += 15;
    if (text.includes('light wind')) score += 5;
    if (text.includes('mild')) score += 10;
    if (text.includes('rain')) score -= 30;
    if (text.includes('snow') || text.includes('flurries')) score -= 40;
    if (text.includes('thunder') || text.includes('lightning')) score -= 50;
    if (text.includes('heavy wind')) score -= 20;
    if (text.includes('fog')) score -= 15;
    if (text.includes('freezing')) score -= 25;
    if (text.includes('extreme')) score -= 30;
    return Math.max(0, Math.min(100, score));
}
/**
 * Renders the weekly weather forecast as interactive day boxes
 * 
 * @function renderWeatherDays
 * @param {Array<Object>} forecasts - Array of forecast objects
 * @returns {void}
 */
function renderWeatherDays(forecasts) {
    const weekDaysContainer = document.getElementById('weekDays');
    weekDaysContainer.innerHTML = '';
    const today = new Date();
    const daysOfWeek = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
    const dailyForecasts = [];
    for (let i = 0; i < Math.min(14, forecasts.length); i += 2) {
        const dayForecast = forecasts[i];
        const nightForecast = forecasts[i+1] || forecasts[i];
        dailyForecasts.push({
            dayForecast,
            nightForecast
        });
    }
    while (dailyForecasts.length < 7) {
        dailyForecasts.push({
            dayForecast: createEmptyForecast(daysOfWeek[(today.getDay() + dailyForecasts.length) % 7]),
            nightForecast: createEmptyForecast(daysOfWeek[(today.getDay() + dailyForecasts.length) % 7] + ' night')
        });
    }
    for (let i = 0; i < 7; i++) {
        const dayIndex = (today.getDay() + i) % 7;
        const dayName = daysOfWeek[dayIndex];
        const forecast = dailyForecasts[i] || {
            dayForecast: createEmptyForecast(dayName),
            nightForecast: createEmptyForecast(dayName + ' night')
        };
        const dayBox = document.createElement('div');
        dayBox.className = 'day-box';
        dayBox.id = `day-${dayName.replace(/\s/g, '-')}`;
        const outdoorScore = forecast.nightForecast ? 
            Math.round((forecast.dayForecast.outdoorScore + forecast.nightForecast.outdoorScore) / 2) : 
            forecast.dayForecast.outdoorScore;
        const hue = (outdoorScore * 1.2).toString(10);
        dayBox.style.background = `linear-gradient(135deg, hsl(${hue}, 80%, 50%), hsl(${hue}, 80%, 40%))`;
        dayBox.innerHTML = `
            <div class="day-name">${dayName}</div>
            <div class="weather-icon"><i class="fas fa-${forecast.dayForecast.icon}"></i></div>
            <div class="temp-display">${forecast.dayForecast.temp || '--'}</div>
        `;
        dayBox.addEventListener('click', () => {
            selectDay(dayName);
            showWeatherPopup(forecast.dayForecast, forecast.nightForecast, dayName);
        });
        dayBox.dataset.forecast = JSON.stringify({
            dayName,
            dayForecast: forecast.dayForecast,
            nightForecast: forecast.nightForecast,
            outdoorScore
        });
        weekDaysContainer.appendChild(dayBox);
    }
    updateActivityHeatmap(forecasts);
}
/**
 * Creates an empty forecast object when real data is unavailable
 * 
 * @function createEmptyForecast
 * @param {string} time - The time period for the forecast
 * @returns {Object} A forecast object with default values
 */
function createEmptyForecast(time) {
    return {
        time: time,
        temp: '--',
        icon: 'question',
        outdoorScore: 50,
        forecastText: 'Data not available',
        fullSummary: 'Weather data is currently unavailable for this day.'
    };
}
/**
 * Displays a popup with detailed weather forecast information
 * 
 * @function showWeatherPopup
 * @param {Object} dayForecast - The day forecast object
 * @param {Object} nightForecast - The night forecast object
 * @param {string} dayName - The name of the day being displayed
 * @returns {void}
 */
function showWeatherPopup(dayForecast, nightForecast, dayName) {
    const popup = document.getElementById('weatherPopup');
    const popupTitle = document.getElementById('weatherPopupTitle');
    const popupContent = document.getElementById('weatherPopupContent');
    popupTitle.textContent = `${dayName} Weather Forecast`;
    let contentHTML = `
        <div class="weather-popup-row">
            <div class="weather-popup-icon">
                <i class="fas fa-${dayForecast.icon}"></i>
            </div>
            <div class="weather-popup-details">
                <div class="weather-popup-label">Day Forecast</div>
                <div class="weather-popup-value">${dayForecast.forecastText}</div>
            </div>
        </div>
    `;
    if (nightForecast) {
        contentHTML += `
            <div class="weather-popup-row">
                <div class="weather-popup-icon">
                    <i class="fas fa-${nightForecast.icon}"></i>
                </div>
                <div class="weather-popup-details">
                    <div class="weather-popup-label">Night Forecast</div>
                    <div class="weather-popup-value">${nightForecast.forecastText}</div>
                </div>
            </div>
        `;
    }
    contentHTML += `
        <div class="weather-popup-row">
            <div class="weather-popup-icon">
                <i class="fas fa-temperature-low"></i>
            </div>
            <div class="weather-popup-details">
                <div class="weather-popup-label">Temperature</div>
                <div class="weather-popup-value">Day: ${dayForecast.temp} | Night: ${nightForecast?.temp || dayForecast.temp}</div>
            </div>
        </div>
    `;
    const outdoorScore = nightForecast ? 
        Math.round((dayForecast.outdoorScore + nightForecast.outdoorScore) / 2) : 
        dayForecast.outdoorScore;
    contentHTML += `
        <div class="weather-popup-row">
            <div class="weather-popup-icon">
                <i class="fas fa-running"></i>
            </div>
            <div class="weather-popup-details">
                <div class="weather-popup-label">Outdoor Activity Score</div>
                <div class="weather-popup-value">${outdoorScore}/100 - ${getWeatherAssessment(outdoorScore)}</div>
            </div>
        </div>
    `;
    if (dayForecast.fullSummary) {
        contentHTML += `
            <div class="weather-popup-row">
                <div class="weather-popup-icon">
                    <i class="fas fa-info-circle"></i>
                </div>
                <div class="weather-popup-details">
                    <div class="weather-popup-label">Detailed Forecast</div>
                    <div class="weather-popup-value" style="font-size: 0.9rem;">${dayForecast.fullSummary}</div>
                </div>
            </div>
        `;
    }
    popupContent.innerHTML = contentHTML;
    popup.style.display = 'block';
}
/**
 * Handles selection of a day in the weather forecast display
 * 
 * @function selectDay
 * @param {string} dayName - The name of the selected day
 * @returns {void}
 */
function selectDay(dayName) {
    if (selectedDay) {
        document.getElementById(selectedDay)?.classList.remove('selected');
    }
    selectedDay = `day-${dayName}`;
    const dayBox = document.getElementById(selectedDay);
    if (dayBox) {
        dayBox.classList.add('selected');
    }
    document.querySelectorAll('.day-box').forEach(box => {
        if (box.id !== selectedDay) {
            box.classList.add('not-selected');
        } else {
            box.classList.remove('not-selected');
        }
    });
}
/**
 * Generates a human-readable assessment of weather conditions
 * 
 * @function getWeatherAssessment
 * @param {number} score - The outdoor activity score (0-100)
 * @returns {string} A descriptive assessment of conditions
 */
function getWeatherAssessment(score) {
    if (score > 80) return "⭐⭐⭐⭐⭐ Excellent weather for outdoor events! Ideal conditions with pleasant temperatures and minimal precipitation risk.";
    if (score > 60) return "⭐⭐⭐⭐ Good conditions for outdoor events. Generally favorable weather with some minor considerations.";
    if (score > 40) return "⭐⭐⭐ Fair conditions - consider backup plans or protective measures. Some weather factors may impact your event.";
    if (score > 20) return "⭐⭐ Poor conditions for outdoor events. Strongly consider alternatives or rescheduling.";
    return "⭐ Very poor conditions - recommend indoor alternatives or rescheduling. Significant weather risks present.";
}
/**
 * Displays a temporary alert message to the user
 * 
 * @function showAlert
 * @param {string} message - The message to display
 * @param {string} [type='info'] - The type of alert ('info', 'success', 'warning', 'error')
 * @returns {void}
 */
function showAlert(message, type = 'info') {
    const colors = {
        info: '#3498db',
        success: '#2ecc71',
        warning: '#f39c12',
        error: '#e74c3c'
    };
    const alert = document.createElement('div');
    alert.style.position = 'fixed';
    alert.style.top = '20px';
    alert.style.right = '20px';
    alert.style.padding = '15px 20px';
    alert.style.background = colors[type] || colors.info;
    alert.style.color = 'white';
    alert.style.borderRadius = '8px';
    alert.style.boxShadow = '0 4px 12px rgba(0,0,0,.15)';
    alert.style.zIndex = '1000';
    alert.style.display = 'flex';
    alert.style.alignItems = 'center';
    alert.style.gap = '10px';
    alert.style.animation = 'slideIn 0.3s ease-out';
    alert.innerHTML = `
        <i class="fas fa-${type === 'error' ? 'exclamation-triangle' : type === 'warning' ? 'exclamation-circle' : type === 'success' ? 'check-circle' : 'info-circle'}"></i>
        <span>${message}</span>
    `;
    document.body.appendChild(alert);
    setTimeout(() => {
        alert.style.animation = 'slideOut 0.3s ease-in';
        setTimeout(() => alert.remove(), 300);
    }, 3000);
}

const outdoorActivities = [
    { id: 'hiking', name: 'Hiking', icon: 'fa-hiking' },
    { id: 'camping', name: 'Camping', icon: 'fa-campground' },
    { id: 'water', name: 'Water Activities', icon: 'fa-water' },
    { id: 'winter', name: 'Winter Sports', icon: 'fa-snowboarding' },
    { id: 'wildlife', name: 'Wildlife Watching', icon: 'fa-binoculars' }
];
/**
 * Updates the outdoor activity heatmap based on forecast data
 * 
 * @function updateActivityHeatmap
 * @param {Array<Object>} forecasts - Array of forecast objects
 * @returns {void}
 */
function updateActivityHeatmap(forecasts) {
    const heatmapContent = document.getElementById('heatmapContent');
    const heatmapYAxis = document.getElementById('heatmapYAxis');
    const heatmapXAxis = document.getElementById('heatmapXAxis');
    heatmapContent.innerHTML = '';
    heatmapYAxis.innerHTML = '';
    heatmapXAxis.innerHTML = '';
    outdoorActivities.forEach(activity => {
        const yLabel = document.createElement('div');
        yLabel.className = 'heatmap-chart-y-label';
        yLabel.innerHTML = `
            <i class="fas ${activity.icon}"></i>
            <span>${activity.name}</span>
        `;
        heatmapYAxis.appendChild(yLabel);
    });
    const today = new Date();
    const daysOfWeek = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
    for (let i = 0; i < 7; i++) {
        const dayIndex = (today.getDay() + i) % 7;
        const xLabel = document.createElement('div');
        xLabel.className = 'heatmap-chart-x-label';
        xLabel.textContent = daysOfWeek[dayIndex];
        heatmapXAxis.appendChild(xLabel);
    }
    const dailyForecasts = [];
    for (let i = 0; i < Math.min(14, forecasts.length); i += 2) {
        const dayForecast = forecasts[i];
        const nightForecast = forecasts[i+1] || forecasts[i];
        dailyForecasts.push({
            dayForecast,
            nightForecast
        });
    }
    while (dailyForecasts.length < 7) {
        dailyForecasts.push({
            dayForecast: createEmptyForecast(''),
            nightForecast: createEmptyForecast('')
        });
    }
    outdoorActivities.forEach(activity => {
        for (let i = 0; i < 7; i++) {
            const forecast = dailyForecasts[i] || {
                dayForecast: createEmptyForecast(''),
                nightForecast: createEmptyForecast('')
            };
            const score = calculateActivityScore(activity.id, forecast.dayForecast, forecast.nightForecast);
            const scoreCell = document.createElement('div');
            scoreCell.className = 'heatmap-cell';
            const hue = (score * 1.2).toString(10);
            scoreCell.style.background = `hsla(${hue}, 80%, 50%, 0.7)`;
            scoreCell.title = `${activity.name} suitability on ${daysOfWeek[(today.getDay() + i) % 7]}: ${score}/100`;
            heatmapContent.appendChild(scoreCell);
        }
    });
}
/**
 * Calculates a suitability score for a specific outdoor activity
 * 
 * @function calculateActivityScore
 * @param {string} activityId - The activity identifier
 * @param {Object} dayForecast - The day forecast object
 * @param {Object} nightForecast - The night forecast object
 * @returns {number} A score from 0-100 representing activity suitability
 */
function calculateActivityScore(activityId, dayForecast, nightForecast) {
    const dayText = (dayForecast.forecastText + ' ' + dayForecast.fullSummary).toLowerCase();
    const nightText = (nightForecast.forecastText + ' ' + nightForecast.fullSummary).toLowerCase();
    const combinedText = dayText + ' ' + nightText;
    let score = 50;
    let temp = 15;
    const tempMatch = dayForecast.temp.match(/(-?\d+)/);
    if (tempMatch) {
        temp = parseInt(tempMatch[1]);
    }
    switch(activityId) {
        case 'hiking':
            if (temp >= 10 && temp <= 25) score += 20;
            else if (temp > 25) score -= (temp - 25) * 2;
            else if (temp < 10) score -= (10 - temp) * 2;
            if (dayText.includes('sunny') || dayText.includes('clear')) score += 15;
            if (dayText.includes('partly cloudy')) score += 10;
            if (dayText.includes('rain')) score -= 30;
            if (dayText.includes('snow')) score -= 40;
            if (dayText.includes('wind')) score -= 15;
            break;
        case 'camping':
            if (temp >= 15 && temp <= 25) score += 20;
            else if (temp > 25) score -= (temp - 25);
            else if (temp < 15) score -= (15 - temp);
            if (!dayText.includes('rain') && !dayText.includes('snow')) score += 15;
            if (dayText.includes('clear') || dayText.includes('sunny')) score += 10;
            if (dayText.includes('rain')) score -= 25;
            if (dayText.includes('snow')) score -= 35;
            if (dayText.includes('thunder') || dayText.includes('lightning')) score -= 30;
            if (dayText.includes('wind')) score -= 10;
            break;
        case 'water':
            if (temp >= 20) score += (temp - 15) * 2;
            else score -= (20 - temp) * 3;
            if (dayText.includes('sunny')) score += 15;
            if (dayText.includes('rain')) score -= 20;
            if (dayText.includes('thunder') || dayText.includes('lightning')) score -= 30;
            if (dayText.includes('wind')) score -= 15;
            break;
        case 'winter':
            if (temp <= 0) score += (0 - temp) * 2;
            else score -= temp * 3;
            if (dayText.includes('snow')) score += 25;
            if (dayText.includes('sunny')) score += 10;
            if (dayText.includes('rain')) score -= 30;
            if (dayText.includes('above freezing')) score -= 20;
            break;
        case 'wildlife':
            if (temp >= 5 && temp <= 25) score += 15;
            else if (temp > 25) score -= (temp - 25);
            else if (temp < 5) score -= (5 - temp);
            if (!dayText.includes('heavy rain') && !dayText.includes('heavy snow')) score += 10;
            if (dayText.includes('clear') || dayText.includes('sunny')) score += 10;
            if (dayText.includes('heavy rain') || dayText.includes('heavy snow')) score -= 25;
            if (dayText.includes('extreme')) score -= 20;
            break;
    }
    return Math.max(0, Math.min(100, Math.round(score)));
}

document.getElementById('infoButton').addEventListener('click', function(e) {
    e.stopPropagation();
    document.getElementById('infoPanel').style.display = 'block';
});
document.getElementById('closeInfoPanel').addEventListener('click', function(e) {
    e.stopPropagation();
    document.getElementById('infoPanel').style.display = 'none';
});
document.addEventListener('click', function(e) {
    if (!document.getElementById('infoPanel').contains(e.target) && 
        e.target !== document.getElementById('infoButton')) {
        document.getElementById('infoPanel').style.display = 'none';
    }
});
window.onload = init;
</script>
</body>
</html>
