<!DOCTYPE html>
<html>
<head>
<title>Weather Dashboard with Multiple Metrics</title>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css">
<script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://cdn.jsdelivr.net/npm/luxon@3.0.1"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-luxon@1.2.0"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@1.0.2"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
<link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
<style>
:root {
    --primary: #4361ee;
    --secondary: #3f37c9;
    --success: #4cc9f0;
    --danger: #f72585;
    --warning: #f8961e;
    --light: #f8f9fa;
    --dark: #212529;
    --text: #2b2d42;
    --muted: #6c757d;
}

body {
    font-family: 'Poppins', sans-serif;
    margin: 0;
    padding: 0;
    overflow: hidden;
    color: var(--text);
}

#container {
    display: grid;
    grid-template-columns: 1fr 1fr;
    grid-template-rows: auto 1fr;
    height: 100vh;
    gap: 10px;
    padding: 10px;
    background-color: #f5f7fa;
}

#map-container {
    grid-column: 1;
    grid-row: 1 / span 2;
    position: relative;
    border-radius: 8px;
    overflow: hidden;
    box-shadow: 0 1px 3px rgba(0,0,0,.1);
}

#map {
    width: 100%;
    height: 100%;
}

#visualizer-container {
    grid-column: 2;
    grid-row: 1;
    display: flex;
    flex-direction: column;
    background: #fff;
    border-radius: 8px;
    box-shadow: 0 1px 3px rgba(0,0,0,.1);
    overflow: hidden;
}

#right-panel {
    grid-column: 2;
    grid-row: 2;
    display: flex;
    flex-direction: column;
    background: #fff;
    border-radius: 8px;
    box-shadow: 0 1px 3px rgba(0,0,0,.1);
    overflow: hidden;
}

/* Map controls */
.map-controls {
    position: absolute;
    top: 20px;
    right: 20px;
    z-index: 1000;
    display: flex;
    flex-direction: column;
    gap: 10px;
    background: rgba(255,255,255,0.9);
    padding: 15px;
    border-radius: 8px;
    box-shadow: 0 1px 5px rgba(0,0,0,.2);
    width: 220px;
    backdrop-filter: blur(5px);
}

.map-controls-group {
    margin-bottom: 10px;
}

.map-controls-label {
    font-size: 12px;
    font-weight: 500;
    margin-bottom: 5px;
    display: block;
    color: var(--text);
}

.map-layer-select, .province-select {
    width: 100%;
    padding: 8px 12px;
    border: 1px solid #ddd;
    border-radius: 4px;
    font-size: 14px;
    background-color: #fff;
    cursor: pointer;
    transition: all 0.2s;
}

.map-layer-select:focus, .province-select:focus {
    outline: 0;
    border-color: var(--primary);
    box-shadow: 0 0 0 2px rgba(67, 97, 238, 0.2);
}

/* Metric point styles */
.metric-point {
    width: 38px;
    height: 38px;
    border-radius: 50%;
    border: 2px solid white;
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    display: flex;
    justify-content: center;
    align-items: center;
    color: white;
    font-weight: bold;
    font-size: 12px;
    transform: translate(-50%, -50%);
    text-shadow: 1px 1px 2px rgba(0,0,0,0.7);
}

.metric-point:hover {
    transform: translate(-50%, -50%) scale(1.4);
    z-index: 1000;
}

/* Temperature classes */
.metric-point.temp-freezing { background-color: #0000ff; } /* -20°C and below */
.metric-point.temp-very-cold { background-color: #0066ff; } /* -10°C to -19°C */
.metric-point.temp-cold { background-color: #00ccff; } /* 0°C to -9°C */
.metric-point.temp-cool { background-color: #00ffcc; } /* 1°C to 10°C */
.metric-point.temp-mild { background-color: #ffff00; } /* 11°C to 20°C */
.metric-point.temp-warm { background-color: #ff9900; } /* 21°C to 30°C */
.metric-point.temp-hot { background-color: #ff0000; } /* 31°C and above */

/* Wind speed classes */
.metric-point.wind-calm { background-color: #4CAF50; } /* 0-10 km/h */
.metric-point.wind-light { background-color: #8BC34A; } /* 11-20 km/h */
.metric-point.wind-moderate { background-color: #FFC107; } /* 21-30 km/h */
.metric-point.wind-strong { background-color: #FF9800; } /* 31-50 km/h */
.metric-point.wind-gale { background-color: #FF5722; } /* 51-70 km/h */
.metric-point.wind-storm { background-color: #F44336; } /* 71+ km/h */

/* Humidity classes */
.metric-point.humid-dry { background-color: #FF9800; } /* 0-30% */
.metric-point.humid-comfortable { background-color: #4CAF50; } /* 31-60% */
.metric-point.humid-humid { background-color: #2196F3; } /* 61-80% */
.metric-point.humid-very-humid { background-color: #3F51B5; } /* 81-100% */

/* Pressure classes */
.metric-point.pressure-low { background-color: #F44336; } /* < 98 kPa */
.metric-point.pressure-normal { background-color: #4CAF50; } /* 98-102 kPa */
.metric-point.pressure-high { background-color: #2196F3; } /* > 102 kPa */

/* Visibility classes */
.metric-point.visibility-poor { background-color: #F44336; } /* < 1 km */
.metric-point.visibility-moderate { background-color: #FFC107; } /* 1-5 km */
.metric-point.visibility-good { background-color: #4CAF50; } /* 5-10 km */
.metric-point.visibility-excellent { background-color: #2196F3; } /* > 10 km */

/* Metric legend */
.metric-legend {
    position: absolute;
    bottom: 20px;
    left: 20px;
    right: 20px;
    z-index: 1000;
    background: rgba(255,255,255,0.9);
    padding: 10px 15px;
    border-radius: 8px;
    box-shadow: 0 1px 5px rgba(0,0,0,.2);
    backdrop-filter: blur(5px);
    display: flex;
    flex-direction: column;
}

.metric-legend-title {
    font-size: 12px;
    font-weight: 600;
    margin-bottom: 8px;
    color: var(--text);
    text-align: center;
}

.metric-legend-scale {
    display: flex;
    height: 20px;
    width: 100%;
    border-radius: 4px;
    overflow: hidden;
}

.metric-legend-labels {
    display: flex;
    justify-content: space-between;
    margin-top: 5px;
}

.metric-legend-label {
    font-size: 10px;
    color: var(--text);
}

/* Metric switcher */
.metric-switcher {
    position: absolute;
    bottom: 120px;
    right: 20px;
    z-index: 2000;
    background: rgba(255,255,255,0.9);
    padding: 5px;
    border-radius: 8px;
    box-shadow: 0 1px 5px rgba(0,0,0,.2);
    backdrop-filter: blur(5px);
    display: flex;
    align-items: center;
}

.metric-btn {
    background: none;
    border: none;
    padding: 5px 10px;
    cursor: pointer;
    font-size: 12px;
    color: var(--muted);
    transition: all 0.2s;
}

.metric-btn.active {
    color: var(--primary);
    font-weight: 500;
}

.metric-btn i {
    font-size: 14px;
}

/* Unit switcher */
.unit-switcher {
    display: flex;
    background: #f0f2f5;
    border-radius: 20px;
    padding: 2px;
    margin-top: 10px;
}

.unit-btn {
    border: none;
    background: none;
    padding: 5px 10px;
    font-size: 12px;
    cursor: pointer;
    border-radius: 20px;
    transition: all 0.2s;
}

.unit-btn.active {
    background: var(--primary);
    color: white;
}

/* Visualizer styles */
.visualizer-city-switcher {
    padding: 15px;
    display: flex;
    align-items: center;
    gap: 10px;
    background: rgba(255,255,255,0.8);
    border-bottom: 1px solid #eee;
}

.visualizer-city-switcher select {
    padding: 8px 12px;
    border-radius: 4px;
    border: 1px solid #ddd;
    flex-grow: 1;
    font-family: inherit;
}

.visualizer-city-switcher button {
    padding: 8px 15px;
    background-color: var(--primary);
    color: #fff;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-family: inherit;
    transition: all 0.2s;
}

.visualizer-city-switcher button:hover {
    background-color: var(--secondary);
}

.visualizer-city-switcher button:disabled {
    background-color: #ccc;
    cursor: not-allowed;
}

.visualizer-loading {
    text-align: center;
    padding: 40px 20px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    height: 100%;
}

.loading-spinner {
    border: 3px solid rgba(0,0,0,.1);
    border-radius: 50%;
    border-top: 3px solid var(--primary);
    width: 30px;
    height: 30px;
    animation: spin 1s linear infinite;
    margin: 0 auto 15px;
}

@keyframes spin {
    to { transform: rotate(360deg); }
}

.visualizer-error {
    color: var(--danger);
    padding: 15px;
    margin: 15px;
    background-color: #fee;
    border-radius: 5px;
    display: none;
}

.visualizer-visuals {
    padding: 15px;
    flex-grow: 1;
    overflow: auto;
}

.visuals-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
    gap: 12px;
}

.visual-card {
    border: 1px solid #ddd;
    border-radius: 8px;
    overflow: hidden;
    box-shadow: 0 2px 4px rgba(0,0,0,.05);
    transition: all 0.2s ease;
    aspect-ratio: 1/1;
    display: flex;
    flex-direction: column;
    background: #fff;
    cursor: pointer;
}

.visual-card:hover {
    transform: translateY(-3px);
    box-shadow: 0 5px 15px rgba(0,0,0,.1);
}

.visual-card-header {
    padding: 12px;
    flex-grow: 1;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    text-align: center;
}

.visual-card-header h3 {
    margin: 0 0 5px 0;
    font-size: 13px;
    color: var(--text);
    font-weight: 500;
}

.current-value {
    font-size: 18px;
    font-weight: 700;
    color: #333;
    margin: 5px 0;
    text-shadow: none;
}

.unit {
    font-size: 11px;
    color: var(--muted);
}

.no-visuals {
    text-align: center;
    padding: 30px;
    color: #666;
    grid-column: 1/-1;
}

/* Event planner styles */
.controls-container {
    padding: 20px;
    overflow-y: auto;
    flex: 1;
}

.current-date {
    font-size: 1.5em;
    font-weight: 700;
    color: var(--text);
    margin-bottom: 20px;
}

.glass-card {
    background: rgba(255,255,255,0.9);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border-radius: 16px;
    box-shadow: 0 8px 32px rgba(31,38,135,.1);
    border: 1px solid rgba(255,255,255,.18);
    overflow: hidden;
    margin-bottom: 20px;
}

.event-planner-header {
    text-align: center;
    padding: 1.5rem 1rem;
    background: linear-gradient(135deg, var(--primary) 0, var(--secondary) 100%);
    color: #fff;
    border-radius: 16px 16px 0 0;
    position: relative;
    overflow: hidden;
}

.event-planner-title {
    font-weight: 700;
    font-size: 1.5rem;
    margin-bottom: .5rem;
    text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
}

.event-planner-subtitle {
    font-weight: 300;
    opacity: .9;
    font-size: .9rem;
    text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
}

.event-planner-content {
    padding: 1.5rem;
}

.event-planner-loading {
    text-align: center;
    padding: 1rem;
    color: var(--muted);
    font-style: italic;
    animation: pulse 2s infinite;
}

@keyframes pulse {
    0% { opacity: .6 }
    50% { opacity: 1 }
    100% { opacity: .6 }
}

.week-days {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(90px, 1fr));
    gap: .7rem;
    margin-bottom: 1.5rem;
}

.day-box {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 1rem .5rem;
    border-radius: 12px;
    cursor: pointer;
    transition: all .3s cubic-bezier(.25,.8,.25,1);
    position: relative;
    overflow: hidden;
    z-index: 1;
    color: #fff;
    text-shadow: 1px 1px 2px rgba(0,0,0,0.7);
}

.day-box::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0,0,0,.1);
    z-index: -1;
}

.day-box:hover {
    transform: translateY(-5px) scale(1.03);
    box-shadow: 0 10px 20px rgba(0,0,0,.15);
}

.day-name {
    font-weight: 600;
    font-size: .95rem;
    margin-bottom: .5rem;
}

.weather-icon {
    font-size: 1.5rem;
    margin-bottom: .8rem;
    transition: all .3s;
}

.temp-display {
    font-size: .9rem;
    background: rgba(255,255,255,.25);
    padding: .3rem .8rem;
    border-radius: 20px;
    backdrop-filter: blur(5px);
}

.event-form {
    display: flex;
    flex-direction: column;
    gap: 1rem;
}

.form-group {
    display: flex;
    flex-direction: column;
    margin-bottom: .5rem;
}

.event-planner-label {
    font-weight: 500;
    margin-bottom: .5rem;
    color: var(--text);
    font-size: .95rem;
}

.event-planner-input, .event-planner-textarea {
    padding: .8rem 1rem;
    border: 1px solid rgba(0,0,0,.1);
    border-radius: 8px;
    font-size: 1rem;
    transition: all .3s;
    background: rgba(255,255,255,.7);
    width: 100%;
    font-family: inherit;
}

.event-planner-input:focus, .event-planner-textarea:focus {
    outline: 0;
    border-color: var(--primary);
    box-shadow: 0 0 0 3px rgba(67,97,238,.2);
    background: #fff;
}

.event-planner-textarea {
    min-height: 100px;
    resize: vertical;
}

.submit-btn {
    background: linear-gradient(135deg, var(--primary) 0, var(--secondary) 100%);
    color: #fff;
    border: none;
    padding: .8rem 1.5rem;
    border-radius: 8px;
    font-size: 1rem;
    font-weight: 500;
    cursor: pointer;
    transition: all .3s;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    align-self: flex-start;
    box-shadow: 0 4px 6px rgba(0,0,0,.1);
    position: relative;
    overflow: hidden;
    margin-top: .5rem;
    font-family: inherit;
    text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
}

.submit-btn::before {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255,255,255,.2), transparent);
    transition: .5s;
}

.submit-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 12px rgba(0,0,0,.15);
}

.submit-btn:hover::before {
    left: 100%;
}

.submit-btn i {
    margin-right: .5rem;
}

.selected {
    transform: scale(1.05);
    box-shadow: 0 0 0 3px #fff, 0 8px 25px rgba(0,0,0,.2);
    z-index: 2;
}

.not-selected {
    filter: grayscale(70%) brightness(.9);
    opacity: .7;
    transform: scale(.95);
}

.event-planner-footer {
    text-align: center;
    margin-top: 1rem;
    color: var(--muted);
    font-size: .8rem;
}

/* Modal styles */
.modal {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0,0,0,.7);
    z-index: 2000;
    justify-content: center;
    align-items: center;
}

.modal-content {
    background: #fff;
    padding: 25px;
    border-radius: 10px;
    width: 90%;
    max-width: 1200px;
    max-height: 90vh;
    overflow-y: auto;
}

.modal-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 20px;
}

.modal-title {
    font-size: 24px;
    font-weight: 700;
    color: var(--text);
}

.close-modal {
    font-size: 28px;
    cursor: pointer;
    color: var(--muted);
    transition: color 0.2s;
}

.close-modal:hover {
    color: var(--danger);
}

.modal-chart-container {
    position: relative;
    width: 100%;
    height: 600px;
    margin-bottom: 20px;
}

.chart-container {
    width: 100%;
    height: 100%;
}

/* Weather Popup Styles */
.weather-popup {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: white;
    padding: 20px;
    border-radius: 10px;
    box-shadow: 0 5px 15px rgba(0,0,0,0.3);
    z-index: 3000;
    max-width: 400px;
    width: 90%;
    animation: fadeIn 0.3s ease-out;
}

.weather-popup-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 15px;
    padding-bottom: 10px;
    border-bottom: 1px solid #eee;
}

.weather-popup-title {
    font-size: 1.3rem;
    font-weight: 600;
    color: var(--primary);
    margin: 0;
    text-shadow: none;
}

.weather-popup-close {
    font-size: 1.5rem;
    cursor: pointer;
    color: var(--muted);
    transition: color 0.2s;
}

.weather-popup-close:hover {
    color: var(--danger);
}

.weather-popup-content {
    margin-bottom: 15px;
}

.weather-popup-row {
    display: flex;
    margin-bottom: 10px;
    align-items: center;
}

.weather-popup-icon {
    font-size: 1.8rem;
    width: 50px;
    text-align: center;
    margin-right: 15px;
    color: var(--primary);
}

.weather-popup-details {
    flex: 1;
}

.weather-popup-label {
    font-weight: 500;
    color: var(--text);
    margin-bottom: 3px;
}

.weather-popup-value {
    font-size: 1.1rem;
    color: #333;
}

.weather-popup-footer {
    text-align: center;
    font-size: 0.9rem;
    color: var(--muted);
    margin-top: 15px;
    padding-top: 10px;
    border-top: 1px solid #eee;
}

@keyframes fadeIn {
    from { opacity: 0; transform: translate(-50%, -55%); }
    to { opacity: 1; transform: translate(-50%, -50%); }
}

/* Loading overlay for initial load */
.loading-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(255,255,255,0.9);
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    z-index: 9999;
}

.loading-overlay-spinner {
    border: 5px solid rgba(0,0,0,.1);
    border-radius: 50%;
    border-top: 5px solid var(--primary);
    width: 50px;
    height: 50px;
    animation: spin 1s linear infinite;
    margin-bottom: 20px;
}

.loading-overlay-text {
    font-size: 1.2rem;
    color: var(--text);
    margin-top: 15px;
}

/* Responsive adjustments */
@media (max-width: 1200px) {
    #container {
        grid-template-columns: 1fr;
        grid-template-rows: auto auto auto;
    }
    
    #map-container {
        grid-column: 1;
        grid-row: 1;
        height: 400px;
    }
    
    #visualizer-container {
        grid-column: 1;
        grid-row: 2;
    }
    
    #right-panel {
        grid-column: 1;
        grid-row: 3;
    }
}
</style>
</head>
<body>
<!-- Loading overlay that will be shown while fetching initial data -->
<div class="loading-overlay" id="loadingOverlay">
    <div class="loading-overlay-spinner"></div>
    <div class="loading-overlay-text">Loading weather data for all cities...</div>
</div>

<div id="container">
    <div id="map-container">
        <div id="map"></div>
        <div class="map-controls">
            <div class="map-controls-group">
                <label class="map-controls-label">Map Style</label>
                <select class="map-layer-select" id="mapLayerSelect">
                    <option value="osm" selected>OpenStreetMap</option>
                    <option value="osm-classic">OSM Classic</option>
                    <option value="osm-humanitarian">OSM Humanitarian</option>
                    <option value="carto-positron">CartoDB Positron</option>
                    <option value="carto-dark">CartoDB Dark</option>
                    <option value="stamen-toner">Stamen Toner</option>
                    <option value="stamen-terrain">Stamen Terrain</option>
                    <option value="stamen-watercolor">Stamen Watercolor</option>
                    <option value="esri-imagery">Esri Imagery</option>
                    <option value="esri-topo">Esri Topo</option>
                </select>
            </div>
            <div class="map-controls-group">
                <label class="map-controls-label">Units</label>
                <div class="unit-switcher">
                    <button class="unit-btn active" id="metricBtn">Metric (°C, km/h)</button>
                    <button class="unit-btn" id="imperialBtn">Imperial (°F, mph)</button>
                </div>
            </div>
        </div>
        
        <!-- Metric switcher -->
        <div class="metric-switcher">
            <button class="metric-btn" id="prevMetricBtn"><i class="fas fa-chevron-left"></i></button>
            <button class="metric-btn active" id="currentMetricBtn">Temperature</button>
            <button class="metric-btn" id="nextMetricBtn"><i class="fas fa-chevron-right"></i></button>
        </div>
        
        <!-- Legend will be updated dynamically -->
        <div class="metric-legend" id="metricLegend">
            <div class="metric-legend-title" id="metricLegendTitle">Temperature (°C)</div>
            <div class="metric-legend-scale" id="metricLegendScale" style="background: linear-gradient(to right, #0000ff, #0066ff, #00ccff, #00ffcc, #ffff00, #ff9900, #ff0000);"></div>
            <div class="metric-legend-labels" id="metricLegendLabels">
                <div class="metric-legend-label">-20°</div>
                <div class="metric-legend-label">-10°</div>
                <div class="metric-legend-label">0°</div>
                <div class="metric-legend-label">10°</div>
                <div class="metric-legend-label">20°</div>
                <div class="metric-legend-label">30°</div>
                <div class="metric-legend-label">40°</div>
            </div>
        </div>
    </div>
    <div id="visualizer-container">
        <div class="visualizer-city-switcher">
            <select id="visualizerCitySelect">
                <option value="yfc">Fredericton (YFC)</option>
                <option value="yhz">Halifax (YHZ)</option>
                <option value="yyt">St. John's (YYT)</option>
                <option value="yyg">Charlottetown (YYG)</option>
                <option value="yqb">Quebec City (YQB)</option>
                <option value="yow">Ottawa (YOW)</option>
                <option value="yyz">Toronto (YYZ)</option>
                <option value="yqr" selected>Regina (YQR)</option>
                <option value="ywg">Winnipeg (YWG)</option>
                <option value="yeg">Edmonton (YEG)</option>
                <option value="yxy">Whitehorse (YXY)</option>
                <option value="yzf">Yellowknife (YZF)</option>
                <option value="yyj">Victoria (YYJ)</option>
            </select>
            <button id="visualizerFetchBtn">Update</button>
        </div>
        <div id="visualizerLoading" class="visualizer-loading">
            <div class="loading-spinner"></div>
            <p>Loading weather data...</p>
        </div>
        <div id="visualizerError" class="visualizer-error"></div>
        <div id="visualizerVisuals" class="visualizer-visuals">
            <div id="visualizerGrid" class="visuals-grid"></div>
        </div>
    </div>
    <div id="right-panel">
        <div id="controls-container">
            <div class="current-date" id="currentDate"></div>
            <div class="glass-card">
                <div class="event-planner-header">
                    <div class="event-planner-title">Weather Event Planner</div>
                    <div class="event-planner-subtitle">Plan your outdoor activities based on weather forecasts</div>
                </div>
                <div class="event-planner-content">
                    <div id="eventPlannerLoading" class="event-planner-loading">
                        <i class="fas fa-cloud-sun fa-spin" style="font-size:1.5rem;margin-bottom:.5rem"></i>
                        <p>Fetching latest weather data...</p>
                    </div>
                    <div class="week-days" id="weekDays" style="display:none"></div>
                    <div class="event-form">
                        <div class="form-group">
                            <label for="eventName" class="event-planner-label"><i class="fas fa-calendar-alt"></i> Event Name</label>
                            <input type="text" id="eventName" class="event-planner-input" placeholder="e.g., Garden Party, Marathon, Outdoor Wedding">
                        </div>
                        <div class="form-group">
                            <label for="eventDetails" class="event-planner-label"><i class="fas fa-info-circle"></i> Event Details</label>
                            <textarea id="eventDetails" class="event-planner-textarea" placeholder="Describe your event including time, expected attendance, special requirements, etc."></textarea>
                        </div>
                        <button class="submit-btn" id="sendEmailBtn"><i class="fas fa-paper-plane"></i> Generate Event Plan</button>
                    </div>
                </div>
                <div class="event-planner-footer">
                    <p>Powered by Environment Canada Weather Data</p>
                </div>
            </div>
        </div>
    </div>
</div>

<div class="modal" id="visualizerModal">
    <div class="modal-content">
        <span class="close-modal">&times;</span>
        <h2 class="modal-title" id="visualizerModalTitle">Metric Name</h2>
        <div class="modal-current-value" id="visualizerModalCurrentValue">--</div>
        <div class="modal-chart-container">
            <canvas id="visualizerModalChart"></canvas>
        </div>
    </div>
</div>

<!-- Weather Popup -->
<div class="weather-popup" id="weatherPopup" style="display: none;">
    <div class="weather-popup-header">
        <h3 class="weather-popup-title" id="weatherPopupTitle">Weather Forecast</h3>
        <span class="weather-popup-close" id="weatherPopupClose">&times;</span>
    </div>
    <div class="weather-popup-content" id="weatherPopupContent">
        <!-- Content will be inserted here dynamically -->
    </div>
    <div class="weather-popup-footer">
        Powered by Environment Canada Weather Data
    </div>
</div>

<script>
// Define all the tile layers
const tileLayers = {
    'osm': L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
    }),
    'osm-classic': L.tileLayer('https://{s}.tile.openstreetmap.fr/osmfr/{z}/{x}/{y}.png', {
        attribution: '&copy; OpenStreetMap France | &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
    }),
    'osm-humanitarian': L.tileLayer('https://{s}.tile.openstreetmap.fr/hot/{z}/{x}/{y}.png', {
        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors, Tiles courtesy of <a href="https://hot.openstreetmap.org/" target="_blank">Humanitarian OpenStreetMap Team</a>'
    }),
    'carto-positron': L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png', {
        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors, &copy; <a href="https://carto.com/attribution">CARTO</a>'
    }),
    'carto-dark': L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}.png', {
        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors, &copy; <a href="https://carto.com/attribution">CARTO</a>'
    }),
    'stamen-toner': L.tileLayer('https://tiles.stadiamaps.com/tiles/stamen_toner/{z}/{x}/{y}.png', {
        attribution: 'Map tiles by <a href="http://stamen.com">Stamen Design</a>, under <a href="http://creativecommons.org/licenses/by/4.0">CC BY 4.0</a>. Data by <a href="http://openstreetmap.org">OpenStreetMap</a>, under <a href="http://www.openstreetmap.org/copyright">ODbL</a>.',
        subdomains: 'abcd'
    }),
    'stamen-terrain': L.tileLayer('https://tiles.stadiamaps.com/tiles/stamen_terrain/{z}/{x}/{y}.png', {
        attribution: 'Map tiles by <a href="http://stamen.com">Stamen Design</a>, under <a href="http://creativecommons.org/licenses/by/4.0">CC BY 4.0</a>. Data by <a href="http://openstreetmap.org">OpenStreetMap</a>, under <a href="http://www.openstreetmap.org/copyright">ODbL</a>.',
        subdomains: 'abcd'
    }),
    'stamen-watercolor': L.tileLayer('https://tiles.stadiamaps.com/tiles/stamen_watercolor/{z}/{x}/{y}.png', {
        attribution: 'Map tiles by <a href="http://stamen.com">Stamen Design</a>, under <a href="http://creativecommons.org/licenses/by/4.0">CC BY 4.0</a>. Data by <a href="http://openstreetmap.org">OpenStreetMap</a>, under <a href="http://www.openstreetmap.org/copyright">ODbL</a>.',
        subdomains: 'abcd'
    }),
    'esri-imagery': L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
        attribution: 'Tiles &copy; Esri &mdash; Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community'
    }),
    'esri-topo': L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Topo_Map/MapServer/tile/{z}/{y}/{x}', {
        attribution: 'Tiles &copy; Esri &mdash; Esri, DeLorme, NAVTEQ, TomTom, Intermap, iPC, USGS, FAO, NPS, NRCAN, GeoBase, Kadaster NL, Ordnance Survey, Esri Japan, METI, Esri China (Hong Kong), and the GIS User Community'
    })
};

// City data for visualizer with coordinates (capital cities of all provinces)
const cityData = {
    yfc: {
        name: "Fredericton",
        province: "New Brunswick",
        station: "yfc",
        url: "https://weather.gc.ca/past_conditions/index_e.html?station=yfc",
        lat: 45.9636,
        lng: -66.6431
    },
    yhz: {
        name: "Halifax",
        province: "Nova Scotia",
        station: "yhz",
        url: "https://weather.gc.ca/past_conditions/index_e.html?station=yhz",
        lat: 44.6488,
        lng: -63.5752
    },
    yyt: {
        name: "St. John's",
        province: "Newfoundland and Labrador",
        station: "yyt",
        url: "https://weather.gc.ca/past_conditions/index_e.html?station=yyt",
        lat: 47.5615,
        lng: -52.7126
    },
    yyg: {
        name: "Charlottetown",
        province: "Prince Edward Island",
        station: "yyg",
        url: "https://weather.gc.ca/past_conditions/index_e.html?station=yyg",
        lat: 46.2382,
        lng: -63.1311
    },
    yqb: {
        name: "Quebec City",
        province: "Quebec",
        station: "yqb",
        url: "https://weather.gc.ca/past_conditions/index_e.html?station=yqb",
        lat: 46.8139,
        lng: -71.2080
    },
    yow: {
        name: "Ottawa",
        province: "Ontario",
        station: "yow",
        url: "https://weather.gc.ca/past_conditions/index_e.html?station=yow",
        lat: 45.3225,
        lng: -75.6692
    },
    yyz: {
        name: "Toronto",
        province: "Ontario",
        station: "yyz",
        url: "https://weather.gc.ca/past_conditions/index_e.html?station=yyz",
        lat: 43.6777,
        lng: -79.6248
    },
    yqr: {
        name: "Regina",
        province: "Saskatchewan",
        station: "yqr",
        url: "https://weather.gc.ca/past_conditions/index_e.html?station=yqr",
        lat: 50.4322,
        lng: -104.666
    },
    ywg: {
        name: "Winnipeg",
        province: "Manitoba",
        station: "ywg",
        url: "https://weather.gc.ca/past_conditions/index_e.html?station=ywg",
        lat: 49.8951,
        lng: -97.1384
    },
    yeg: {
        name: "Edmonton",
        province: "Alberta",
        station: "yeg",
        url: "https://weather.gc.ca/past_conditions/index_e.html?station=yeg",
        lat: 53.5461,
        lng: -113.4938
    },
    yxy: {
        name: "Whitehorse",
        province: "Yukon",
        station: "yxy",
        url: "https://weather.gc.ca/past_conditions/index_e.html?station=yxy",
        lat: 60.7212,
        lng: -135.0568
    },
    yzf: {
        name: "Yellowknife",
        province: "Northwest Territories",
        station: "yzf",
        url: "https://weather.gc.ca/past_conditions/index_e.html?station=yzf",
        lat: 62.4530,
        lng: -114.3718
    },
    yyj: {
        name: "Victoria",
        province: "British Columbia",
        station: "yyj",
        url: "https://weather.gc.ca/past_conditions/index_e.html?station=yyj",
        lat: 48.4284,
        lng: -123.3656
    }
};

// Wind direction abbreviations
const windDirections = [
    'N', 'NNE', 'NE', 'ENE', 'E', 'ESE', 'SE', 'SSE',
    'S', 'SSW', 'SW', 'WSW', 'W', 'WNW', 'NW', 'NNW'
];

// Global variables
let map;
let tempMarkers = {};
let visualizerModalChart;
let selectedDay = null;
let weatherForecastData = [];
let visualizerChartData = {};
let currentUnit = 'metric'; // 'metric' or 'imperial'
let currentCityMetrics = {}; // Store all metrics for each city
let currentMetric = 'temperature'; // 'temperature', 'wind', 'humidity', 'pressure', 'visibility'
let metricNames = {
    temperature: 'Temperature',
    wind: 'Wind Speed',
    humidity: 'Humidity',
    pressure: 'Pressure',
    visibility: 'Visibility'
};
let metricUnits = {
    temperature: { metric: '°C', imperial: '°F' },
    wind: { metric: 'km/h', imperial: 'mph' },
    humidity: { metric: '%', imperial: '%' },
    pressure: { metric: 'kPa', imperial: 'inHg' },
    visibility: { metric: 'km', imperial: 'mi' }
};

// Initialize the application
async function init() {
    // Show loading overlay while we fetch all city temperatures
    document.getElementById('loadingOverlay').style.display = 'flex';
    
    try {
        // First fetch all city metrics
        await fetchAllCityMetrics();
        
        // Then initialize the map with real data
        initMap();
        updateCurrentDate();
        loadWeatherForecast();
        setupVisualizer();
        
        // Hide loading overlay
        document.getElementById('loadingOverlay').style.display = 'none';
        
    } catch (error) {
        console.error('Initialization error:', error);
        document.getElementById('loadingOverlay').innerHTML = `
            <div style="text-align: center; color: var(--danger);">
                <i class="fas fa-exclamation-triangle" style="font-size: 2rem; margin-bottom: 1rem;"></i>
                <p>Failed to load initial weather data. Please refresh the page to try again.</p>
                <button onclick="window.location.reload()" style="margin-top: 1rem; background: var(--primary); color: white; border: none; padding: 0.5rem 1rem; border-radius: 5px; cursor: pointer;">
                    <i class="fas fa-sync-alt"></i> Refresh Page
                </button>
            </div>
        `;
    }
    
    // Unit switcher
    document.getElementById('metricBtn').addEventListener('click', () => {
        if (currentUnit !== 'metric') {
            currentUnit = 'metric';
            document.getElementById('metricBtn').classList.add('active');
            document.getElementById('imperialBtn').classList.remove('active');
            updateMapMarkers();
        }
    });
    
    document.getElementById('imperialBtn').addEventListener('click', () => {
        if (currentUnit !== 'imperial') {
            currentUnit = 'imperial';
            document.getElementById('imperialBtn').classList.add('active');
            document.getElementById('metricBtn').classList.remove('active');
            updateMapMarkers();
        }
    });
    
    // Metric switcher
    document.getElementById('prevMetricBtn').addEventListener('click', () => {
        const metrics = Object.keys(metricNames);
        const currentIndex = metrics.indexOf(currentMetric);
        const newIndex = (currentIndex - 1 + metrics.length) % metrics.length;
        setCurrentMetric(metrics[newIndex]);
    });
    
    document.getElementById('nextMetricBtn').addEventListener('click', () => {
        const metrics = Object.keys(metricNames);
        const currentIndex = metrics.indexOf(currentMetric);
        const newIndex = (currentIndex + 1) % metrics.length;
        setCurrentMetric(metrics[newIndex]);
    });
    
    // Email functionality for event planner
    document.getElementById('sendEmailBtn').addEventListener('click', function() {
        const eventName = document.getElementById('eventName').value;
        const eventDetails = document.getElementById('eventDetails').value;
        
        if (!selectedDay) {
            showAlert('Please select a day for your event', 'warning');
            return;
        }
        
        if (!eventName) {
            showAlert('Please enter an event name', 'warning');
            return;
        }
        
        const selectedDayElement = document.getElementById(selectedDay);
        const forecastData = JSON.parse(selectedDayElement.dataset.forecast);
        
        const conditionMap = {
            'sun': 'Sunny',
            'cloud-rain': 'Rainy',
            'snowflake': 'Snow',
            'bolt': 'Thunderstorm',
            'cloud': 'Cloudy',
            'cloud-sun': 'Partly Cloudy',
            'wind': 'Windy',
            'smog': 'Foggy'
        };
        
        const dayIcon = forecastData.dayForecast.icon;
        const dayCondition = conditionMap[dayIcon] || 'Unknown';
        const nightCondition = forecastData.nightForecast ? 
            conditionMap[forecastData.nightForecast.icon] || 'Unknown' : 
            dayCondition;
        
        const subject = `Event Plan: ${eventName} on ${forecastData.dayName}`;
        const body = `
**EVENT PLAN**
----------------------------
📅 Event Name: ${eventName}
📆 Planned Day: ${forecastData.dayName}

🌤️ WEATHER FORECAST:
---------------------
☀️ Day: ${dayCondition} | ${forecastData.dayForecast.temp}
🌙 Night: ${nightCondition} | ${forecastData.nightForecast?.temp || forecastData.dayForecast.temp}

📝 DETAILS:
-----------
${eventDetails}

🔍 WEATHER ASSESSMENT:
----------------------
${getWeatherAssessment(forecastData.outdoorScore)}

---
This plan was generated by Weather Event Planner using live data from Environment Canada
`;
        
        window.location.href = `mailto:?subject=${encodeURIComponent(subject)}&body=${encodeURIComponent(body)}`;
    });

    // Setup weather popup close button
    document.getElementById('weatherPopupClose').addEventListener('click', () => {
        document.getElementById('weatherPopup').style.display = 'none';
    });
}

// Set the current metric and update UI
function setCurrentMetric(metric) {
    currentMetric = metric;
    document.getElementById('currentMetricBtn').textContent = metricNames[metric];
    updateLegend();
    updateMapMarkers();
}

// Update the legend based on current metric
function updateLegend() {
    const legendTitle = document.getElementById('metricLegendTitle');
    const legendScale = document.getElementById('metricLegendScale');
    const legendLabels = document.getElementById('metricLegendLabels');
    
    switch(currentMetric) {
        case 'temperature':
            legendTitle.textContent = `Temperature (${currentUnit === 'metric' ? '°C' : '°F'})`;
            legendScale.style.background = 'linear-gradient(to right, #0000ff, #0066ff, #00ccff, #00ffcc, #ffff00, #ff9900, #ff0000)';
            
            if (currentUnit === 'metric') {
                legendLabels.innerHTML = `
                    <div class="metric-legend-label">-20°</div>
                    <div class="metric-legend-label">-10°</div>
                    <div class="metric-legend-label">0°</div>
                    <div class="metric-legend-label">10°</div>
                    <div class="metric-legend-label">20°</div>
                    <div class="metric-legend-label">30°</div>
                    <div class="metric-legend-label">40°</div>
                `;
            } else {
                legendLabels.innerHTML = `
                    <div class="metric-legend-label">-4°</div>
                    <div class="metric-legend-label">14°</div>
                    <div class="metric-legend-label">32°</div>
                    <div class="metric-legend-label">50°</div>
                    <div class="metric-legend-label">68°</div>
                    <div class="metric-legend-label">86°</div>
                    <div class="metric-legend-label">104°</div>
                `;
            }
            break;
            
        case 'wind':
            legendTitle.textContent = `Wind Speed (${currentUnit === 'metric' ? 'km/h' : 'mph'})`;
            legendScale.style.background = 'linear-gradient(to right, #4CAF50, #8BC34A, #FFC107, #FF9800, #FF5722, #F44336)';
            
            if (currentUnit === 'metric') {
                legendLabels.innerHTML = `
                    <div class="metric-legend-label">0</div>
                    <div class="metric-legend-label">10</div>
                    <div class="metric-legend-label">20</div>
                    <div class="metric-legend-label">30</div>
                    <div class="metric-legend-label">50</div>
                    <div class="metric-legend-label">70</div>
                    <div class="metric-legend-label">100+</div>
                `;
            } else {
                legendLabels.innerHTML = `
                    <div class="metric-legend-label">0</div>
                    <div class="metric-legend-label">6</div>
                    <div class="metric-legend-label">12</div>
                    <div class="metric-legend-label">19</div>
                    <div class="metric-legend-label">31</div>
                    <div class="metric-legend-label">43</div>
                    <div class="metric-legend-label">62+</div>
                `;
            }
            break;
            
        case 'humidity':
            legendTitle.textContent = 'Humidity (%)';
            legendScale.style.background = 'linear-gradient(to right, #FF9800, #FFC107, #8BC34A, #4CAF50, #2196F3, #3F51B5)';
            legendLabels.innerHTML = `
                <div class="metric-legend-label">0</div>
                <div class="metric-legend-label">20</div>
                <div class="metric-legend-label">40</div>
                <div class="metric-legend-label">60</div>
                <div class="metric-legend-label">80</div>
                <div class="metric-legend-label">90</div>
                <div class="metric-legend-label">100</div>
            `;
            break;
            
        case 'pressure':
            legendTitle.textContent = `Pressure (${currentUnit === 'metric' ? 'kPa' : 'inHg'})`;
            legendScale.style.background = 'linear-gradient(to right, #F44336, #FF9800, #FFC107, #8BC34A, #4CAF50, #2196F3)';
            
            if (currentUnit === 'metric') {
                legendLabels.innerHTML = `
                    <div class="metric-legend-label">96</div>
                    <div class="metric-legend-label">98</div>
                    <div class="metric-legend-label">100</div>
                    <div class="metric-legend-label">102</div>
                    <div class="metric-legend-label">104</div>
                    <div class="metric-legend-label">106</div>
                    <div class="metric-legend-label">108</div>
                `;
            } else {
                legendLabels.innerHTML = `
                    <div class="metric-legend-label">28.3</div>
                    <div class="metric-legend-label">28.9</div>
                    <div class="metric-legend-label">29.5</div>
                    <div class="metric-legend-label">30.1</div>
                    <div class="metric-legend-label">30.7</div>
                    <div class="metric-legend-label">31.3</div>
                    <div class="metric-legend-label">31.9</div>
                `;
            }
            break;
            
        case 'visibility':
            legendTitle.textContent = `Visibility (${currentUnit === 'metric' ? 'km' : 'mi'})`;
            legendScale.style.background = 'linear-gradient(to right, #F44336, #FFC107, #8BC34A, #4CAF50, #2196F3)';
            
            if (currentUnit === 'metric') {
                legendLabels.innerHTML = `
                    <div class="metric-legend-label">0</div>
                    <div class="metric-legend-label">2</div>
                    <div class="metric-legend-label">5</div>
                    <div class="metric-legend-label">10</div>
                    <div class="metric-legend-label">20</div>
                    <div class="metric-legend-label">30</div>
                    <div class="metric-legend-label">40+</div>
                `;
            } else {
                legendLabels.innerHTML = `
                    <div class="metric-legend-label">0</div>
                    <div class="metric-legend-label">1.2</div>
                    <div class="metric-legend-label">3.1</div>
                    <div class="metric-legend-label">6.2</div>
                    <div class="metric-legend-label">12.4</div>
                    <div class="metric-legend-label">18.6</div>
                    <div class="metric-legend-label">25+</div>
                `;
            }
            break;
    }
}

// Fetch all metrics for all cities before initializing the map
async function fetchAllCityMetrics() {
    const cityKeys = Object.keys(cityData);
    
    // Create an array of promises for all city fetches
    const fetchPromises = cityKeys.map(async cityKey => {
        const city = cityData[cityKey];
        try {
            const metrics = await fetchCityMetrics(city);
            currentCityMetrics[cityKey] = metrics;
            return { cityKey, metrics, success: true };
        } catch (error) {
            console.error(`Failed to fetch metrics for ${city.name}:`, error);
            // Use reasonable fallback values based on location
            const fallbackMetrics = getFallbackMetrics(city.lat);
            currentCityMetrics[cityKey] = fallbackMetrics;
            return { cityKey, metrics: fallbackMetrics, success: false };
        }
    });
    
    // Wait for all fetches to complete (successful or not)
    const results = await Promise.all(fetchPromises);
    
    // Log results for debugging
    results.forEach(result => {
        if (!result.success) {
            console.warn(`Used fallback metrics for ${cityData[result.cityKey].name}`);
        }
    });
}

// Fetch metrics for a single city
async function fetchCityMetrics(city) {
    const proxyUrl = 'https://api.allorigins.win/raw?url=';
    const targetUrl = city.url;
    
    // Add timeout to prevent hanging
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 10000);
    
    const response = await fetch(proxyUrl + encodeURIComponent(targetUrl), {
        signal: controller.signal
    });
    clearTimeout(timeoutId);
    
    if (!response.ok) throw new Error('Network response was not ok');
    
    const html = await response.text();
    const parser = new DOMParser();
    const doc = parser.parseFromString(html, 'text/html');
    const table = doc.querySelector('table.table-striped');
    
    if (!table) throw new Error('Weather table not found in the response');
    
    const tableClone = table.cloneNode(true);
    tableClone.querySelectorAll('img').forEach(img => img.remove());
    return extractCityMetrics(tableClone);
}

// Extract all metrics from the table
function extractCityMetrics(table) {
    const headers = Array.from(table.querySelectorAll('thead th')).map(th => th.textContent.trim());
    const rows = Array.from(table.querySelectorAll('tbody tr'));
    
    // Find current hour
    const currentHour = new Date().getHours().toString().padStart(2, '0') + ":00";
    const currentRow = rows.find(row => 
        row.querySelector('td')?.textContent.trim() === currentHour
    ) || rows[0]; // Fallback to first row if current hour not found
    
    if (!currentRow) throw new Error('No data rows found');
    
    const cells = Array.from(currentRow.querySelectorAll('td'));
    
    // Helper function to extract numeric value from cell
    const extractValue = (headerText) => {
        const index = headers.findIndex(h => h.includes(headerText));
        if (index === -1) return null;
        
        const cellText = cells[index]?.textContent.trim();
        if (!cellText) return null;
        
        const match = cellText.match(/-?\d+\.?\d*/);
        return match ? parseFloat(match[0]) : null;
    };
    
    // Extract all metrics
    const metrics = {
        temperature: extractValue('Temperature') || getFallbackTemperature(city.lat),
        windSpeed: extractValue('Wind') || getRandomInRange(5, 20),
        humidity: extractValue('Relative humidity') || getRandomInRange(30, 80),
        pressure: extractValue('Pressure') || getRandomInRange(98, 102),
        visibility: extractValue('Visibility') || getRandomInRange(5, 20)
    };
    
    return metrics;
}

// Get fallback metrics based on latitude
function getFallbackMetrics(latitude) {
    return {
        temperature: getFallbackTemperature(latitude),
        windSpeed: getRandomInRange(5, 20),
        humidity: getRandomInRange(30, 80),
        pressure: getRandomInRange(98, 102),
        visibility: getRandomInRange(5, 20)
    };
}

// Get a fallback temperature based on latitude (for when API fails)
function getFallbackTemperature(latitude) {
    // Simple approximation: colder further north, warmer further south
    // Base temperature at 45°N (Toronto) is 10°C, with -1°C per 1° latitude
    const baseTemp = 10;
    const latDiff = latitude - 45;
    return baseTemp - latDiff;
}

// Helper function to get random number in range
function getRandomInRange(min, max) {
    return Math.random() * (max - min) + min;
}

// Initialize the map
function initMap() {
    map = L.map('map', {
        minZoom: 2,
        maxZoom: 18
    }).setView([50.4322, -104.666], 4);
    
    tileLayers.osm.addTo(map);
    
    document.getElementById('mapLayerSelect').addEventListener('change', function() {
        const layerKey = this.value;
        Object.values(tileLayers).forEach(layer => map.removeLayer(layer));
        tileLayers[layerKey].addTo(map);
    });
    
    // Plot all city points on the map with actual metrics
    plotCityPoints();
}

// Plot all city points on the map
function plotCityPoints() {
    Object.keys(cityData).forEach(cityKey => {
        createOrUpdateMarker(cityKey);
    });
}

// Helper function to create or update a city marker
function createOrUpdateMarker(cityKey) {
    const city = cityData[cityKey];
    const metrics = currentCityMetrics[cityKey];
    
    if (!metrics) return;
    
    // Determine value and class based on current metric
    let value, metricClass, displayValue;
    
    switch(currentMetric) {
        case 'temperature':
            value = metrics.temperature;
            displayValue = currentUnit === 'metric' ? value : (value * 9/5 + 32);
            
            if (value <= -20) metricClass = 'temp-freezing';
            else if (value <= -10) metricClass = 'temp-very-cold';
            else if (value <= 0) metricClass = 'temp-cold';
            else if (value <= 10) metricClass = 'temp-cool';
            else if (value <= 20) metricClass = 'temp-mild';
            else if (value <= 30) metricClass = 'temp-warm';
            else metricClass = 'temp-hot';
            break;
            
        case 'wind':
            value = metrics.windSpeed;
            displayValue = currentUnit === 'metric' ? value : (value * 0.621371);
            
            if (value <= 10) metricClass = 'wind-calm';
            else if (value <= 20) metricClass = 'wind-light';
            else if (value <= 30) metricClass = 'wind-moderate';
            else if (value <= 50) metricClass = 'wind-strong';
            else if (value <= 70) metricClass = 'wind-gale';
            else metricClass = 'wind-storm';
            break;
            
        case 'humidity':
            value = metrics.humidity;
            displayValue = value;
            
            if (value <= 30) metricClass = 'humid-dry';
            else if (value <= 60) metricClass = 'humid-comfortable';
            else if (value <= 80) metricClass = 'humid-humid';
            else metricClass = 'humid-very-humid';
            break;
            
        case 'pressure':
            value = metrics.pressure;
            displayValue = currentUnit === 'metric' ? value : (value * 0.2953); // Convert kPa to inHg
            
            if (value < 98) metricClass = 'pressure-low';
            else if (value <= 102) metricClass = 'pressure-normal';
            else metricClass = 'pressure-high';
            break;
            
        case 'visibility':
            value = metrics.visibility;
            displayValue = currentUnit === 'metric' ? value : (value * 0.621371);
            
            if (value < 1) metricClass = 'visibility-poor';
            else if (value <= 5) metricClass = 'visibility-moderate';
            else if (value <= 10) metricClass = 'visibility-good';
            else metricClass = 'visibility-excellent';
            break;
    }
    
    // Create custom icon
    const metricIcon = L.divIcon({
        className: `metric-point ${metricClass}`,
        html: `<span>${Math.round(displayValue)}</span>`,
        iconSize: [38, 38]
    });
    
    // Remove existing marker if it exists
    if (tempMarkers[cityKey]) {
        map.removeLayer(tempMarkers[cityKey]);
    }
    
    // Create new marker with custom icon
    const marker = L.marker([city.lat, city.lng], {
        icon: metricIcon
    }).addTo(map);
    
    // Add tooltip with city info
    const unit = metricUnits[currentMetric][currentUnit];
    marker.bindTooltip(`
        <b>${city.name}, ${city.province}</b><br>
        ${metricNames[currentMetric]}: ${displayValue.toFixed(1)}${unit}<br>
        <small>Click for detailed weather</small>
    `);
    
    // Add click handler
    marker.on('click', function() {
        document.getElementById('visualizerCitySelect').value = cityKey;
        fetchVisualizerData();
        map.setView([city.lat, city.lng], 10);
    });
    
    // Store marker reference
    tempMarkers[cityKey] = marker;
}

// Update all markers on the map with current metric and units
function updateMapMarkers() {
    Object.keys(tempMarkers).forEach(cityKey => {
        createOrUpdateMarker(cityKey);
    });
}

// Setup the weather visualizer
function setupVisualizer() {
    // Fetch button click handler
    document.getElementById('visualizerFetchBtn').addEventListener('click', fetchVisualizerData);
    
    // Handle city selection changes
    document.getElementById('visualizerCitySelect').addEventListener('change', function() {
        const selectedCity = this.value;
        const city = cityData[selectedCity];
        
        if (city && city.lat && city.lng) {
            // Center map on selected city
            map.setView([city.lat, city.lng], 10);
        }
        
        // Update the forecast for the selected city
        loadWeatherForecast();
        // Fetch new visualizer data
        fetchVisualizerData();
    });
    
    // Modal close buttons
    document.querySelectorAll('.close-modal').forEach(btn => {
        if (btn.parentElement.id === 'visualizerModal') {
            btn.addEventListener('click', closeVisualizerModal);
        }
    });
    
    // Close modal when clicking outside
    window.addEventListener('click', (event) => {
        if (event.target === document.getElementById('visualizerModal')) {
            closeVisualizerModal();
        }
        if (event.target === document.getElementById('weatherPopup')) {
            document.getElementById('weatherPopup').style.display = 'none';
        }
    });
    
    // Load initial data
    fetchVisualizerData();
}

// Fetch data for the visualizer
async function fetchVisualizerData() {
    const fetchBtn = document.getElementById('visualizerFetchBtn');
    const loadingElement = document.getElementById('visualizerLoading');
    const errorElement = document.getElementById('visualizerError');
    const citySelect = document.getElementById('visualizerCitySelect');
    
    // Reset UI
    errorElement.style.display = 'none';
    loadingElement.style.display = 'flex';
    fetchBtn.disabled = true;
    
    // Clear previous data
    document.getElementById('visualizerGrid').innerHTML = '';
    visualizerChartData = {};
    
    // Get selected city
    const selectedCity = citySelect.value;
    const city = cityData[selectedCity];
    
    try {
        const proxyUrl = 'https://api.allorigins.win/raw?url=';
        const targetUrl = city.url;
        
        // Add timeout to prevent hanging
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 10000);
        
        const response = await fetch(proxyUrl + encodeURIComponent(targetUrl), {
            signal: controller.signal
        });
        clearTimeout(timeoutId);
        
        if (!response.ok) throw new Error('Network response was not ok');
        
        const html = await response.text();
        const parser = new DOMParser();
        const doc = parser.parseFromString(html, 'text/html');
        const table = doc.querySelector('table.table-striped');
        
        if (table) {
            const tableClone = table.cloneNode(true);
            tableClone.querySelectorAll('img').forEach(img => img.remove());
            processAndCreateVisualizerCards(tableClone, city.name);
            
            // Extract metrics and update map markers
            const metrics = extractCityMetrics(tableClone);
            if (metrics) {
                currentCityMetrics[selectedCity] = metrics;
                createOrUpdateMarker(selectedCity);
            }
        } else {
            throw new Error('Weather table not found in the response');
        }
    } catch (error) {
        errorElement.textContent = `Error loading data for ${city.name}: ${error.message}`;
        errorElement.style.display = 'block';
        console.error('Fetch error:', error);
    } finally {
        loadingElement.style.display = 'none';
        fetchBtn.disabled = false;
    }
}

// Process table data and create visual cards for the visualizer
function processAndCreateVisualizerCards(table, cityName) {
    const headers = Array.from(table.querySelectorAll('thead th')).map(th => {
        let text = th.textContent.trim();
        // Standardize common metrics
        if (text.includes('Temperature') && text.includes('°C')) {
            text = 'Temperature (°C)';
        } else if (text.includes('Temperature') && text.includes('°F')) {
            text = 'Temperature (°F)';
        } else if (text.includes('Wind') && text.includes('km/h')) {
            text = 'Wind Speed (km/h)';
        } else if (text.includes('Wind') && text.includes('mph')) {
            text = 'Wind Speed (mph)';
        } else if (text.includes('Humidity')) {
            text = 'Humidity (%)';
        } else if (text.includes('Pressure') && text.includes('kPa')) {
            text = 'Pressure (kPa)';
        } else if (text.includes('Pressure') && text.includes('in')) {
            text = 'Pressure (in)';
        } else if (text.includes('Visibility') && text.includes('km')) {
            text = 'Visibility (km)';
        } else if (text.includes('Visibility') && text.includes('mi')) {
            text = 'Visibility (mi)';
        }
        return text;
    });

    const rows = Array.from(table.querySelectorAll('tbody tr'));
    const data = rows.map(row => 
        Array.from(row.querySelectorAll('td')).map(td => {
            const text = td.textContent.trim();
            if (text.includes('/')) {
                const parts = text.split('/').map(part => parseFloat(part));
                if (parts.every(num => !isNaN(num))) {
                    return parts.reduce((a, b) => a + b) / parts.length;
                }
            }
            return text;
        })
    );

    // Find the row for the current hour
    const currentHour = new Date().getHours().toString().padStart(2, '0') + ":00";
    const currentRow = data.find(row => row[0] === currentHour);
    if (!currentRow) {
        document.getElementById('visualizerGrid').innerHTML = 
            `<div class="no-visuals">No data available for current hour (${currentHour}) in ${cityName}</div>`;
        return;
    }

    let cardsCreated = 0;
    headers.forEach((header, colIndex) => {
        if (colIndex === 0) return; // Skip time column
        
        // Skip duplicate headers
        if (cardsCreated > 0 && document.querySelector(`[data-header="${header}"]`)) {
            return;
        }

        // Get all values for the chart
        const allValues = data.map(row => {
            const text = row[colIndex];
            if (typeof text === 'number') return text;
            if (!text || typeof text !== 'string') return null;
            const match = text.match(/-?\d+\.?\d*/);
            return match ? parseFloat(match[0]) : null;
        }).filter(v => v !== null);
        
        if (allValues.length === 0) return;

        // Get current hour's value
        const currentValue = (() => {
            const text = currentRow[colIndex];
            if (typeof text === 'number') return text;
            if (!text || typeof text !== 'string') return null;
            const match = text.match(/-?\d+\.?\d*/);
            return match ? parseFloat(match[0]) : null;
        })();
        
        if (currentValue === null || currentValue === undefined) return;

        // Store data for modal
        visualizerChartData[header] = {
            labels: data.map(row => row[0] || ''),
            values: allValues,
            currentValue: currentValue,
            unit: header.match(/\(([^)]+)\)/)?.[1] || '',
            metricName: header.replace(/\([^)]+\)/, '').trim(),
            city: cityName,
            currentHour: currentHour
        };

        // Create card
        const card = document.createElement('div');
        card.className = 'visual-card';
        card.setAttribute('data-header', header);
        
        const unitMatch = header.match(/\(([^)]+)\)/);
        const unit = unitMatch ? unitMatch[1] : '';
        const metricName = header.replace(/\([^)]+\)/, '').trim();

        // Apply color based on value (for temperature)
        let valueColor = '#2c3e50'; // Default text color
        if (header.includes('Temperature')) {
            valueColor = getTempColor(currentValue);
        } else if (header.includes('Humidity')) {
            // Blue gradient for humidity
            const hue = 240 - (currentValue * 2.4);
            valueColor = `hsl(${hue}, 80%, 50%)`;
        } else if (header.includes('Wind Speed')) {
            // Red gradient for wind speed
            const hue = 0;
            const saturation = Math.min(100, currentValue * 2);
            valueColor = `hsl(${hue}, ${saturation}%, 50%)`;
        } else if (header.includes('Pressure')) {
            // Green to blue for pressure
            const hue = 120 + (currentValue - 98) * 30;
            valueColor = `hsl(${hue}, 80%, 50%)`;
        } else if (header.includes('Visibility')) {
            // Red to green for visibility
            const hue = currentValue * 4;
            valueColor = `hsl(${hue}, 80%, 50%)`;
        }

        card.innerHTML = `
            <div class="visual-card-header">
                <h3 title="${metricName}">${metricName}</h3>
                <div class="current-value" style="color: ${valueColor}">${currentValue.toFixed(1)}</div>
                <div class="unit">${unit}</div>
            </div>
        `;

        card.addEventListener('click', () => {
            openVisualizerModal(header);
        });

        document.getElementById('visualizerGrid').appendChild(card);
        cardsCreated++;
    });

    if (cardsCreated === 0) {
        document.getElementById('visualizerGrid').innerHTML = 
            `<div class="no-visuals">No numeric data found for current hour (${currentHour}) in ${cityName}</div>`;
    }
}

// Get color for temperature value
function getTempColor(temp) {
    if (temp <= -20) return '#0000ff';
    if (temp <= -10) return '#0066ff';
    if (temp <= 0) return '#00ccff';
    if (temp <= 10) return '#00ffcc';
    if (temp <= 20) return '#ffff00';
    if (temp <= 30) return '#ff9900';
    return '#ff0000';
}

// Open modal with expanded chart view
function openVisualizerModal(header) {
    const data = visualizerChartData[header];
    if (!data) return;

    // Update modal content
    document.getElementById('visualizerModalTitle').textContent = `${header} (${data.city}) at ${data.currentHour}`;
    
    let displayValue = data.currentValue;
    let displayUnit = data.unit;
    
    if (currentUnit === 'imperial') {
        if (header.includes('Temperature')) {
            displayValue = displayValue * 9/5 + 32;
            displayUnit = '°F';
        } else if (header.includes('Wind Speed')) {
            displayValue = displayValue * 0.621371;
            displayUnit = 'mph';
        } else if (header.includes('Visibility')) {
            displayValue = displayValue * 0.621371;
            displayUnit = 'mi';
        } else if (header.includes('Pressure')) {
            displayValue = displayValue * 0.2953; // kPa to inHg
            displayUnit = 'inHg';
        }
    }
    
    document.getElementById('visualizerModalCurrentValue').textContent = 
        `${displayValue.toFixed(1)} ${displayUnit}`;

    // Create chart
    const ctx = document.getElementById('visualizerModalChart').getContext('2d');
    if (visualizerModalChart) {
        visualizerModalChart.destroy();
    }
    
    // Prepare chart data
    let chartData = [...data.values];
    let chartUnit = data.unit;
    
    if (currentUnit === 'imperial') {
        if (header.includes('Temperature')) {
            chartData = chartData.map(v => v * 9/5 + 32);
            chartUnit = '°F';
        } else if (header.includes('Wind Speed')) {
            chartData = chartData.map(v => v * 0.621371);
            chartUnit = 'mph';
        } else if (header.includes('Visibility')) {
            chartData = chartData.map(v => v * 0.621371);
            chartUnit = 'mi';
        } else if (header.includes('Pressure')) {
            chartData = chartData.map(v => v * 0.2953);
            chartUnit = 'inHg';
        }
    }
    
    // Highlight current hour in the chart
    const currentIndex = data.labels.indexOf(data.currentHour);
    const pointBackgroundColors = data.labels.map((label, index) => 
        index === currentIndex ? '#ff6384' : '#4CAF50'
    );
    
    // Set line color based on metric type
    let lineColor = '#4CAF50'; // Default green
    if (header.includes('Temperature')) {
        lineColor = '#FF6384'; // Reddish for temperature
    } else if (header.includes('Wind Speed')) {
        lineColor = '#36A2EB'; // Blue for wind
    } else if (header.includes('Humidity')) {
        lineColor = '#9966FF'; // Purple for humidity
    } else if (header.includes('Pressure')) {
        lineColor = '#FF9F40'; // Orange for pressure
    } else if (header.includes('Visibility')) {
        lineColor = '#4BC0C0'; // Teal for visibility
    }
    
    visualizerModalChart = new Chart(ctx, {
        type: 'line',
        data: {
            labels: data.labels,
            datasets: [{
                label: data.metricName,
                data: chartData,
                borderColor: lineColor,
                backgroundColor: 'rgba(76, 175, 80, 0.1)',
                pointBackgroundColor: pointBackgroundColors,
                pointRadius: data.labels.map((label, index) => 
                    index === currentIndex ? 6 : 3
                ),
                tension: 0.1,
                fill: true
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                title: { 
                    display: true, 
                    text: `${header} (${data.city})`,
                    font: { size: 18 }
                },
                legend: {
                    display: false
                },
                tooltip: {
                    callbacks: {
                        label: function(context) {
                            return `${data.metricName}: ${context.parsed.y.toFixed(1)} ${chartUnit}`;
                        }
                    }
                },
                annotation: {
                    annotations: {
                        line1: {
                            type: 'line',
                            yMin: currentUnit === 'metric' ? data.currentValue : 
                                header.includes('Temperature') ? data.currentValue * 9/5 + 32 :
                                header.includes('Wind Speed') ? data.currentValue * 0.621371 :
                                header.includes('Visibility') ? data.currentValue * 0.621371 :
                                header.includes('Pressure') ? data.currentValue * 0.2953 :
                                data.currentValue,
                            yMax: currentUnit === 'metric' ? data.currentValue : 
                                header.includes('Temperature') ? data.currentValue * 9/5 + 32 :
                                header.includes('Wind Speed') ? data.currentValue * 0.621371 :
                                header.includes('Visibility') ? data.currentValue * 0.621371 :
                                header.includes('Pressure') ? data.currentValue * 0.2953 :
                                data.currentValue,
                            borderColor: 'rgb(255, 99, 132)',
                            borderWidth: 2,
                            borderDash: [6, 6],
                            label: {
                                content: 'Current',
                                enabled: true,
                                position: 'left'
                            }
                        }
                    }
                }
            },
            scales: {
                y: { 
                    beginAtZero: false,
                    title: { 
                        display: true, 
                        text: chartUnit
                    }
                },
                x: {
                    title: { display: true, text: 'Time' },
                    ticks: {
                        callback: function(value) {
                            // Highlight current hour in x-axis labels
                            if (this.getLabelForValue(value) === data.currentHour) {
                                return '→ ' + this.getLabelForValue(value) + ' ←';
                            }
                            return this.getLabelForValue(value);
                        }
                    }
                }
            }
        }
    });

    // Show modal
    document.getElementById('visualizerModal').style.display = 'flex';
}

// Close the visualizer modal
function closeVisualizerModal() {
    document.getElementById('visualizerModal').style.display = 'none';
    if (visualizerModalChart) {
        visualizerModalChart.destroy();
        visualizerModalChart = null;
    }
}

// Update current date display
function updateCurrentDate() {
    const date = new Date();
    const options = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' };
    document.getElementById('currentDate').textContent = date.toLocaleDateString('en-CA', options);
}

// Load weather forecast data for event planner
async function loadWeatherForecast() {
    // Default to Regina forecast, but we'll use the selected city
    let rssUrl = 'https://weather.gc.ca/rss/city/sk-32_e.xml';
    
    // Get the selected city
    const selectedCity = document.getElementById('visualizerCitySelect').value;
    const city = cityData[selectedCity];
    
    // Determine the RSS feed based on the city
    switch(selectedCity) {
        case 'yfc': rssUrl = 'https://weather.gc.ca/rss/city/nb-24_e.xml'; break; // Fredericton
        case 'yhz': rssUrl = 'https://weather.gc.ca/rss/city/ns-19_e.xml'; break; // Halifax
        case 'yyt': rssUrl = 'https://weather.gc.ca/rss/city/nl-3_e.xml'; break; // St. John's
        case 'yyg': rssUrl = 'https://weather.gc.ca/rss/city/pe-1_e.xml'; break; // Charlottetown
        case 'yqb': rssUrl = 'https://weather.gc.ca/rss/city/qc-133_e.xml'; break; // Quebec City
        case 'yow': rssUrl = 'https://weather.gc.ca/rss/city/on-118_e.xml'; break; // Ottawa
        case 'yyz': rssUrl = 'https://weather.gc.ca/rss/city/on-143_e.xml'; break; // Toronto
        case 'yqr': rssUrl = 'https://weather.gc.ca/rss/city/sk-32_e.xml'; break; // Regina
        case 'ywg': rssUrl = 'https://weather.gc.ca/rss/city/mb-38_e.xml'; break; // Winnipeg
        case 'yeg': rssUrl = 'https://weather.gc.ca/rss/city/ab-50_e.xml'; break; // Edmonton
        case 'yxy': rssUrl = 'https://weather.gc.ca/rss/city/yt-16_e.xml'; break; // Whitehorse
        case 'yzf': rssUrl = 'https://weather.gc.ca/rss/city/nt-25_e.xml'; break; // Yellowknife
        case 'yyj': rssUrl = 'https://weather.gc.ca/rss/city/bc-85_e.xml'; break; // Victoria
    }
    
    const proxyUrl = 'https://api.allorigins.win/get?url=' + encodeURIComponent(rssUrl);
    const weekDaysContainer = document.getElementById('weekDays');
    const loadingElement = document.getElementById('eventPlannerLoading');
    
    try {
        const response = await fetch(proxyUrl);
        if (!response.ok) throw new Error('Network response was not ok');
        const data = await response.json();
        
        if (data.contents) {
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(data.contents, "text/xml");
            weatherForecastData = parseWeatherData(xmlDoc);
            renderWeatherDays(weatherForecastData);
            loadingElement.style.display = 'none';
            weekDaysContainer.style.display = 'grid';
        } else {
            throw new Error('No content received');
        }
    } catch (error) {
        console.error('Error:', error);
        loadingElement.innerHTML = `
            <i class="fas fa-exclamation-triangle" style="font-size: 1.5rem; margin-bottom: 0.5rem; color: var(--danger);"></i>
            <p>Failed to load weather data. Please try again later.</p>
            <button onclick="loadWeatherForecast()" style="margin-top: 0.5rem; background: var(--primary); color: white; border: none; padding: 0.3rem 0.8rem; border-radius: 5px; cursor: pointer;">
                <i class="fas fa-sync-alt"></i> Retry
            </button>
        `;
    }
}

function parseWeatherData(xmlDoc) {
    const entries = xmlDoc.querySelectorAll('entry');
    const forecasts = [];
    
    entries.forEach(entry => {
        const category = entry.querySelector('category');
        if (category && category.getAttribute('term') === 'Weather Forecasts') {
            const title = entry.querySelector('title').textContent;
            const summary = entry.querySelector('summary').textContent;
            
            // Parse day/time and forecast
            const titleParts = title.split(':');
            const time = titleParts[0].trim();
            const forecastText = titleParts[1].trim();
            
            // Extract temperature
            let temp = '';
            const tempMatch = forecastText.match(/(High|Low) (plus |minus )?(-?\d+)/i);
            if (tempMatch) {
                temp = (tempMatch[2] === 'minus ' ? '-' : '') + tempMatch[3] + '°C';
            }
            
            // Determine weather icon
            const icon = getWeatherIcon(forecastText, summary);
            
            // Calculate outdoor score (0-100)
            const outdoorScore = calculateOutdoorScore(forecastText, summary);
            
            forecasts.push({
                time,
                temp,
                icon,
                outdoorScore,
                forecastText,
                fullSummary: summary
            });
        }
    });
    
    return forecasts;
}

function getWeatherIcon(forecastText, summary) {
    const text = (forecastText + ' ' + summary).toLowerCase();
    
    if (text.includes('sunny') || text.includes('clear')) return 'sun';
    if (text.includes('rain') || text.includes('shower')) return 'cloud-rain';
    if (text.includes('snow') || text.includes('flurries')) return 'snowflake';
    if (text.includes('thunder') || text.includes('lightning')) return 'bolt';
    if (text.includes('cloudy')) return 'cloud';
    if (text.includes('partly cloudy') || text.includes('mix of sun and cloud')) return 'cloud-sun';
    if (text.includes('windy')) return 'wind';
    if (text.includes('fog')) return 'smog';
    return 'cloud';
}

function calculateOutdoorScore(forecastText, summary) {
    const text = (forecastText + ' ' + summary).toLowerCase();
    let score = 50; // Base score
    
    // Positive factors
    if (text.includes('sunny') || text.includes('clear')) score += 30;
    if (text.includes('partly cloudy')) score += 15;
    if (text.includes('light wind')) score += 5;
    if (text.includes('mild')) score += 10;
    
    // Negative factors
    if (text.includes('rain')) score -= 30;
    if (text.includes('snow') || text.includes('flurries')) score -= 40;
    if (text.includes('thunder') || text.includes('lightning')) score -= 50;
    if (text.includes('heavy wind')) score -= 20;
    if (text.includes('fog')) score -= 15;
    if (text.includes('freezing')) score -= 25;
    if (text.includes('extreme')) score -= 30;
    
    // Ensure score is between 0-100
    return Math.max(0, Math.min(100, score));
}

function renderWeatherDays(forecasts) {
    const weekDaysContainer = document.getElementById('weekDays');
    weekDaysContainer.innerHTML = '';
    
    // Group into day/night pairs (assuming even number of forecasts)
    for (let i = 0; i < Math.min(14, forecasts.length); i += 2) {
        const dayForecast = forecasts[i];
        const nightForecast = forecasts[i+1] || forecasts[i]; // Fallback if no night forecast
        
        const dayBox = document.createElement('div');
        dayBox.className = 'day-box';
        dayBox.id = `day-${dayForecast.time.replace(/\s/g, '-')}`;
        
        // Use day forecast for color, but average with night if available
        const outdoorScore = nightForecast ? 
            Math.round((dayForecast.outdoorScore + nightForecast.outdoorScore) / 2) : 
            dayForecast.outdoorScore;
        
        // Set gradient based on outdoor score (using HSL color space)
        const hue = (outdoorScore * 1.2).toString(10);
        dayBox.style.background = `linear-gradient(135deg, hsl(${hue}, 80%, 50%), hsl(${hue}, 80%, 40%))`;
        
        // Extract day name (e.g., "Monday" from "Monday night")
        const dayName = dayForecast.time.replace(/\s*(day|night|morning|afternoon|evening)$/i, '');
        
        dayBox.innerHTML = `
            <div class="day-name">${dayName}</div>
            <div class="weather-icon"><i class="fas fa-${dayForecast.icon}"></i></div>
            <div class="temp-display">${dayForecast.temp}</div>
        `;
        
        dayBox.addEventListener('click', () => {
            selectDay(dayForecast.time);
            showWeatherPopup(dayForecast, nightForecast, dayName);
        });
        
        // Store full data as dataset
        dayBox.dataset.forecast = JSON.stringify({
            dayName,
            dayForecast,
            nightForecast,
            outdoorScore
        });
        
        weekDaysContainer.appendChild(dayBox);
    }
}

// Show weather popup with forecast details
function showWeatherPopup(dayForecast, nightForecast, dayName) {
    const popup = document.getElementById('weatherPopup');
    const popupTitle = document.getElementById('weatherPopupTitle');
    const popupContent = document.getElementById('weatherPopupContent');
    
    // Set popup title
    popupTitle.textContent = `${dayName} Weather Forecast`;
    
    // Create popup content
    let contentHTML = `
        <div class="weather-popup-row">
            <div class="weather-popup-icon">
                <i class="fas fa-${dayForecast.icon}"></i>
            </div>
            <div class="weather-popup-details">
                <div class="weather-popup-label">Day Forecast</div>
                <div class="weather-popup-value">${dayForecast.forecastText}</div>
            </div>
        </div>
    `;
    
    if (nightForecast) {
        contentHTML += `
            <div class="weather-popup-row">
                <div class="weather-popup-icon">
                    <i class="fas fa-${nightForecast.icon}"></i>
                </div>
                <div class="weather-popup-details">
                    <div class="weather-popup-label">Night Forecast</div>
                    <div class="weather-popup-value">${nightForecast.forecastText}</div>
                </div>
            </div>
        `;
    }
    
    // Add temperature information
    contentHTML += `
        <div class="weather-popup-row">
            <div class="weather-popup-icon">
                <i class="fas fa-temperature-low"></i>
            </div>
            <div class="weather-popup-details">
                <div class="weather-popup-label">Temperature</div>
                <div class="weather-popup-value">Day: ${dayForecast.temp} | Night: ${nightForecast?.temp || dayForecast.temp}</div>
            </div>
        </div>
    `;
    
    // Add outdoor activity score
    const outdoorScore = nightForecast ? 
        Math.round((dayForecast.outdoorScore + nightForecast.outdoorScore) / 2) : 
        dayForecast.outdoorScore;
    
    contentHTML += `
        <div class="weather-popup-row">
            <div class="weather-popup-icon">
                <i class="fas fa-running"></i>
            </div>
            <div class="weather-popup-details">
                <div class="weather-popup-label">Outdoor Activity Score</div>
                <div class="weather-popup-value">${outdoorScore}/100 - ${getWeatherAssessment(outdoorScore)}</div>
            </div>
        </div>
    `;
    
    // Add summary if available
    if (dayForecast.fullSummary) {
        contentHTML += `
            <div class="weather-popup-row">
                <div class="weather-popup-icon">
                    <i class="fas fa-info-circle"></i>
                </div>
                <div class="weather-popup-details">
                    <div class="weather-popup-label">Detailed Forecast</div>
                    <div class="weather-popup-value" style="font-size: 0.9rem;">${dayForecast.fullSummary}</div>
                </div>
            </div>
        `;
    }
    
    popupContent.innerHTML = contentHTML;
    popup.style.display = 'block';
}

function selectDay(dayTime) {
    // Deselect previous day
    if (selectedDay) {
        document.getElementById(selectedDay).classList.remove('selected');
    }
    
    // Select new day
    selectedDay = `day-${dayTime.replace(/\s/g, '-')}`;
    const dayBox = document.getElementById(selectedDay);
    dayBox.classList.add('selected');
    
    // Gray out other days
    const allDayBoxes = document.querySelectorAll('.day-box');
    allDayBoxes.forEach(box => {
        if (box.id !== selectedDay) {
            box.classList.add('not-selected');
        } else {
            box.classList.remove('not-selected');
        }
    });
}

function getWeatherAssessment(score) {
    if (score > 80) return "⭐⭐⭐⭐⭐ Excellent weather for outdoor events! Ideal conditions with pleasant temperatures and minimal precipitation risk.";
    if (score > 60) return "⭐⭐⭐⭐ Good conditions for outdoor events. Generally favorable weather with some minor considerations.";
    if (score > 40) return "⭐⭐⭐ Fair conditions - consider backup plans or protective measures. Some weather factors may impact your event.";
    if (score > 20) return "⭐⭐ Poor conditions for outdoor events. Strongly consider alternatives or rescheduling.";
    return "⭐ Very poor conditions - recommend indoor alternatives or rescheduling. Significant weather risks present.";
}

function showAlert(message, type = 'info') {
    const colors = {
        info: '#3498db',
        success: '#2ecc71',
        warning: '#f39c12',
        error: '#e74c3c'
    };
    
    const alert = document.createElement('div');
    alert.style.position = 'fixed';
    alert.style.top = '20px';
    alert.style.right = '20px';
    alert.style.padding = '15px 20px';
    alert.style.background = colors[type] || colors.info;
    alert.style.color = 'white';
    alert.style.borderRadius = '8px';
    alert.style.boxShadow = '0 4px 12px rgba(0,0,0,.15)';
    alert.style.zIndex = '1000';
    alert.style.display = 'flex';
    alert.style.alignItems = 'center';
    alert.style.gap = '10px';
    alert.style.animation = 'slideIn 0.3s ease-out';
    alert.innerHTML = `
        <i class="fas fa-${type === 'error' ? 'exclamation-triangle' : type === 'warning' ? 'exclamation-circle' : type === 'success' ? 'check-circle' : 'info-circle'}"></i>
        <span>${message}</span>
    `;
    
    document.body.appendChild(alert);
    
    setTimeout(() => {
        alert.style.animation = 'slideOut 0.3s ease-in';
        setTimeout(() => alert.remove(), 300);
    }, 3000);
}

// Initialize the application when the page loads
window.onload = init;
</script>
</body>
</html>
